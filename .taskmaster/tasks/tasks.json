{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Setup Project Repository",
        "description": "Initialize the project repository with necessary configurations and dependencies.",
        "details": "1. Initialize a new Git repository.\n2. Set up TypeScript with ES2022 target.\n3. Install necessary dependencies: VS Code API, Task Master CLI, Node.js.\n4. Configure esbuild for bundling.\n5. Set up GitHub Actions for CI/CD.",
        "testStrategy": "Verify repository setup by checking if all dependencies are installed and the project builds successfully.",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Implement CLI Integration Layer",
        "description": "Develop the integration layer to execute Task Master CLI commands and parse outputs.",
        "details": "1. Use Node.js ChildProcess.spawn to execute 'task-master list --with-subtasks --json'.\n2. Implement stdout streaming and incremental parsing.\n3. Set up debounce polling with a configurable interval.",
        "testStrategy": "Mock CLI responses and verify that the integration layer correctly parses and outputs task data.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Develop Task Tree View",
        "description": "Create a TreeDataProvider to render tasks and subtasks in a hierarchical view.",
        "details": "1. Use VS Code's TreeDataProvider API to create a tree view.\n2. Render tasks with ID, title, status, and complexity score.\n3. Implement collapsible dependency branches.",
        "testStrategy": "Test the tree view with mock data to ensure correct rendering and interactivity.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Add Interactive Node Commands",
        "description": "Extend the VS Code extension so users can fully manage and navigate Task-Master tasks directly from the tree view. In addition to opening PRDs and marking tasks complete, users must be able to add and delete tasks (with dependency handling) and quickly navigate to, or display, the next actionable task or any specific task’s details.",
        "status": "done",
        "dependencies": [
          3
        ],
        "priority": "medium",
        "details": "The tree-view context menu should expose the following commands, all of which must rely on the Task-Master CLI and surface clear progress / error messages to the user.\n\n1. Open PRD – runs `task-master open-prd <id>` or simply opens .taskmaster/docs/prd.txt when the selected node represents the project root.\n2. Show in Terminal – runs `task-master show <id>`.\n3. Mark Complete – runs `task-master complete <id>` then refreshes the tree.\n4. Add Task – opens an input box / quick-pick sequence to collect: title, description, priority, dependencies. When confirmed, run `task-master add --title \"…\" --description \"…\" --priority … --deps …`. Refresh the tree afterwards and reveal the new node.\n5. Delete Task –\n   a. Run `task-master validate-dependencies <id>` to determine if other tasks depend on the target.\n   b. If no dependents, confirm deletion and execute `task-master delete <id>`.\n   c. If dependents exist, show them and prompt the user. On confirmation, automatically run `task-master fix-dependencies --remove <id>` and then `task-master delete <id>`.\n   d. Refresh the tree.\n6. Manage Dependencies (context submenu or command palette):\n   • Add Dependency – `task-master add-dependency <srcId> <depId>`\n   • Remove Dependency – `task-master remove-dependency <srcId> <depId>`\n   • Validate Dependencies – `task-master validate-dependencies <id>` (result surfaced in an information message).\n7. Next Task – runs `task-master next` (optionally scoped to the selected node) and then reveals that task in the tree / opens quick-pick to navigate to it.\n8. Show Task Details – same behaviour as Show in Terminal but displayed in an editor tab or webview for richer formatting.\n\nAll menu commands must be registered in package.json, appear contextually (e.g., Delete only for leaf or confirmed tasks), and be covered by telemetry / logging hooks.",
        "testStrategy": "Manual & automated tests (using vscode-test + mocha):\n1. For each command, verify the correct CLI call is assembled and executed (mock the binary in unit tests).\n2. Confirm the tree view refreshes and reflects changes after add, delete, complete, dependency edits.\n3. For Delete Task, prepare tasks with and without dependents and assert the proper confirmation flow and CLI commands sequence.\n4. Validate UI feedback: information, warning, and error messages appear appropriately, and navigation (reveal node, open webview) works.\n5. Integration smoke test: create a mini project, add several tasks with dependencies, mark some complete, run Next Task multiple times, ensuring ordering matches CLI output.",
        "subtasks": [
          {
            "id": 1,
            "title": "Scaffold new commands in package.json and command registration",
            "status": "done"
          },
          {
            "id": 2,
            "title": "Implement Add Task flow with quick-pick and CLI invocation",
            "status": "done"
          },
          {
            "id": 3,
            "title": "Implement Delete Task with dependency checks and confirmations",
            "status": "done"
          },
          {
            "id": 4,
            "title": "Implement Dependency Management commands (add/remove/validate)",
            "status": "done"
          },
          {
            "id": 5,
            "title": "Implement Next Task navigation and task details viewer",
            "status": "done"
          },
          {
            "id": 6,
            "title": "Write unit tests mocking Task-Master CLI interactions",
            "status": "done"
          },
          {
            "id": 7,
            "title": "End-to-end tests creating, deleting, and navigating tasks",
            "status": "done"
          }
        ]
      },
      {
        "id": 5,
        "title": "Implement Status Bar & Telemetry",
        "description": "Develop a status bar item to display the next actionable task and telemetry data.",
        "details": "1. Create a status bar item using VS Code API.\n2. Display the next task using 'task-master next'.\n3. Show real-time AI token cost for Task Master v0.14 and above.",
        "testStrategy": "Test the status bar updates and telemetry display with both mock and real data.",
        "priority": "medium",
        "dependencies": [
          3
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Create Settings UI",
        "description": "Develop a settings interface that allows users to configure the CLI path and automatically persist the selected cycle view so users retain their preferred view across VS Code sessions.\n\nAll requirements have been fully implemented:\n• The CLI path configuration setting and runtime reading logic are finished and verified.\n• Cycle-view selection now persists via globalState and reliably restores on activation.\n• Legacy settings (refreshInterval, enableTelemetry, autoRefresh, securityLevel) have been entirely removed from the codebase and documentation.\n• A complete regression and quality-assurance pass was executed—TypeScript build, ESLint checks, security validation, and the full package build all passed with no issues.\n\nNo additional work remains.",
        "status": "done",
        "dependencies": [
          3
        ],
        "priority": "medium",
        "details": "1. CLI Path setting (COMPLETED)\n   • Exposed `myExtension.cliPath` string setting in package.json via `contributes.configuration`.\n   • `ConfigService` reads the configured value on demand and listens for configuration-change events so the new path is used without requiring a window reload.\n\n2. Cycle-view persistence (COMPLETED)\n   • `StatusBarService` stores the selected cycle-view identifier in `extensionContext.globalState` whenever the user switches views.\n   • On activation, `extension.ts` passes the extension context to `StatusBarService`, which immediately restores the last stored view.\n\n3. Remove legacy options (COMPLETED)\n   • Deleted `refreshInterval`, `enableTelemetry`, `autoRefresh`, and `securityLevel` settings from package.json.\n   • Updated `TaskMasterConfig` interface, simplified `CLIService`, and removed all telemetry functionality from `StatusBarService`.\n   • README and CHANGELOG updated to reflect the removals.\n   • Verified that the Settings UI no longer shows the obsolete options.\n\n4. Regression and runtime compliance (COMPLETED)\n   • Manual and automated tests executed:\n     – TypeScript compilation: PASSED\n     – ESLint code quality: PASSED (fixed curly-brace warning)\n     – Security validation: PASSED (0 issues, 0 warnings)\n     – Package build: PASSED\n   • Confirmed the extension activates without error in clean workspaces and in workspaces containing stale settings.\n",
        "testStrategy": "All tests completed and passed:\n1. CLI Path\n   • Changing `myExtension.cliPath` in Settings immediately updates the runtime configuration; verified again after window reload.\n2. Cycle View Persistence\n   • Selecting a non-default cycle view and reloading VS Code restores the same view automatically.\n3. Legacy Setting Removal Regression\n   • Obsolete settings no longer appear in the Settings UI; no schema warnings for old keys present in user settings.json.\n   • Extension activates cleanly with and without stale settings present.\n4. Full Extension Smoke Test\n   • Activation succeeds with and without stored cycle-view state.\n   • All commands that rely on `cliPath` execute successfully.\n5. Quality & Security Gates\n   • TypeScript compilation, ESLint linting, security validation, and package build all passed with zero errors or warnings.",
        "subtasks": [
          {
            "id": 1,
            "title": "Add CLI path configuration setting",
            "status": "done",
            "description": "Expose a `myExtension.cliPath` string setting in package.json and read it in the extension."
          },
          {
            "id": 2,
            "title": "Persist selected cycle view",
            "status": "done",
            "description": "Store the chosen cycle view in globalState and restore it on activation."
          },
          {
            "id": 3,
            "title": "Update documentation and remove obsolete settings",
            "status": "done",
            "description": "Clean up references to refresh interval and telemetry in README and package.json."
          },
          {
            "id": 4,
            "title": "Testing & verification",
            "status": "done",
            "description": "Run manual and automated tests to confirm persistence, CLI path behavior, regression after removing obsolete settings, and overall build quality. All tests have passed."
          }
        ]
      },
      {
        "id": 7,
        "title": "Ensure Security and Compliance",
        "description": "Implement security measures and ensure compliance with VS Code marketplace requirements.",
        "details": "1. Follow runtime-security guidelines to restrict network calls.\n2. Declare 'untrustedWorkspaces' limitations.\n3. Ensure package is signed and verify with CI.",
        "testStrategy": "Conduct a security audit and verify compliance with marketplace guidelines.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Support Expand Task Command to Break Task into Subtasks",
        "description": "Implement a feature to allow users to expand a task into multiple subtasks within the extension.",
        "details": "To implement the 'expand task' command, first update the command palette to include a new command 'Expand Task'. This command should prompt the user to select a task to expand. Once a task is selected, provide an interface to define subtasks, including title, description, and dependencies for each subtask. Store these subtasks in the task management system, ensuring they are linked to the parent task. Update the task rendering logic to display subtasks hierarchically under their parent task. Consider using a collapsible tree view for better user experience. Ensure that the task data model supports nesting and that the task persistence layer can handle the new structure.",
        "testStrategy": "1. Verify the 'Expand Task' command appears in the command palette and can be executed.\n2. Test the user interface for creating subtasks, ensuring all fields are functional and data is saved correctly.\n3. Check that subtasks are displayed under their parent task in the task view.\n4. Validate that the task data model correctly represents the hierarchy of tasks and subtasks.\n5. Ensure that the task persistence layer saves and loads tasks with subtasks accurately.\n6. Conduct user testing to ensure the feature is intuitive and meets user needs.",
        "status": "done",
        "dependencies": [
          6
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Implement Tag Switching Functionality",
        "description": "Enable users to switch between different task tags within the extension.",
        "details": "To implement tag switching, first update the task management interface to include a dropdown or similar UI element that lists all available tags. This UI component should allow users to select a tag, which will filter the displayed tasks to only those associated with the selected tag. Ensure that the tag data is stored and retrieved efficiently, possibly using a caching mechanism to improve performance. Additionally, update the task rendering logic to dynamically display tasks based on the selected tag. Consider edge cases such as no tasks being associated with a selected tag and provide appropriate user feedback. Ensure the UI is intuitive and integrates seamlessly with existing task management features.",
        "testStrategy": "1. Verify that the tag switching UI component is visible and functional within the task management interface.\n2. Test the functionality by selecting different tags and ensuring that only tasks associated with the selected tag are displayed.\n3. Check the performance of the tag switching feature, ensuring it operates smoothly without significant delay.\n4. Validate that the system handles cases where no tasks are associated with a selected tag, providing appropriate feedback to the user.",
        "status": "done",
        "dependencies": [
          6,
          11
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Extend Data Model and Caching for Tag Retrieval",
            "description": "Introduce or update data structures so each task stores an associated tag list and the full set of tags can be fetched quickly with caching.",
            "dependencies": [],
            "details": "• Update DB schema / local storage to persist tag ↔︎ task relations.\n• Implement a tag repository/service with an in-memory cache (e.g., Map) that invalidates on task/tag mutation events.\n• Expose async methods: getAllTags(), getTasksByTag(tagId).\n• Ensure fallback to API/local storage when cache miss occurs.\n<info added on 2025-06-18T11:12:37.505Z>\n• Introduced strongly-typed models (TagInfo, TagServiceResponse, TagCacheEntry) to standardise tag payloads across services.  \n• Implemented TagService with a 30 s TTL in-memory cache for getAllTags() and getTasksByTag(), including automatic fallback to API/local storage on cache miss.  \n• Wired TaskCacheService to subscribe to tag events, enabling tag-aware cache refreshes after TASK_UPDATED / TAG_UPDATED mutations.  \n• Exposed tag operations (getAllTags, getTasksByTag, setCurrentTag) through TaskManagerService and the VS Code extension command layer.  \n• Adopted event-driven architecture: TagService emits TAG_CACHE_HIT, TAG_CACHE_MISS, and TAG_CACHE_INVALIDATED events consumed by UI and other services for instant updates.  \n• getAllTags()/getTasksByTag() now resolve to an empty array when no matching tags exist, preventing unhandled errors in consumer code.  \n• Persisted currentTag selection in .taskmaster/config.json, re-loading it on extension startup to restore user context.\n</info added on 2025-06-18T11:12:37.505Z>",
            "status": "done",
            "testStrategy": "Unit-test repository functions with mocked storage to verify cache hits/misses and correct data returns."
          },
          {
            "id": 2,
            "title": "Implement Client-Side Filtering Logic",
            "description": "Create reusable functions/selectors that, given a tag ID, return only the tasks that match, leveraging the caching layer.",
            "dependencies": [
              1
            ],
            "details": "• In state management layer (Redux/Vuex/Context), add currentSelectedTag state.\n• Write filterTasksByTag(tagId) that subscribes to task list updates and memoizes results.\n• Ensure it returns empty array immediately if no tasks match, without throwing errors.\n<info added on 2025-06-18T11:19:54.605Z>\n• Added taskFilterUtils.ts housing a TaskFilterManager singleton that maintains per-tag cache with 5-second TTL and memoized results  \n• filterTasksByTag(tagId) now delegates to TaskFilterManager, aligning with server-side CLI tag switching while providing local caching  \n• Introduced helper functions setCurrentSelectedTag, getCurrentSelectedTag and clearFilterCache; state stays in sync via Tag change events emitted by TaskManagerService  \n• Wired TaskFilterManager into TaskCacheService and TagService for automatic cache warm-up, validation and stale-data invalidation  \n• Exposed getFilterStats utility for debugging cache hit/miss ratios and entry age  \n• Verified empty arrays are returned gracefully for unknown or empty tag queries\n</info added on 2025-06-18T11:19:54.605Z>",
            "status": "done",
            "testStrategy": "Unit tests verifying correct subsets are returned for existing, non-existing, and undefined tag values."
          },
          {
            "id": 3,
            "title": "Create Tag Selector UI Component",
            "description": "Add a dropdown (or segmented control) that lists all available tags and triggers selection events.",
            "dependencies": [
              1
            ],
            "details": "• Build a reusable <TagDropdown /> component.\n• On mount, call getAllTags() to populate options.\n• Emit onTagSelected(tagId) when user chooses a tag.\n• Apply current theme/styles and ensure keyboard accessibility.\n<info added on 2025-06-18T12:12:49.153Z>\n• Added TagCommands class exposing selectTag(), quickSwitchTag(), and showCurrentTagInfo() handlers that open a VS Code QuickPick powered by getAllTags(), emit tag-change events, and invoke CLI commands (tags / use-tag) with robust error handling  \n• Extended StatusBarService with a dynamic tag item showing the active tag and task count; click action launches the TagDropdown  \n• Registered “Select Tag” command, status-bar item, and toolbar button in package.json with theme-aware icons and proper menu placement  \n• Wired event bus so tree view and status bar automatically refresh on tag-change; user receives informational toast notifications  \n• Ensured full keyboard navigation, current-tag highlighting, and theme adherence across QuickPick, toolbar, and status-bar entry\n</info added on 2025-06-18T12:12:49.153Z>\n<info added on 2025-06-18T12:16:48.584Z>\n• Refactored TagService to default “tags” and “use-tag” invocations to --format=text and introduced parseTagsOutput() for decoding ASCII table rows (handles current-tag glyph, column spacing, and metadata columns)  \n• Enhanced setCurrentTag() to scan command stdout for “(current)” or “Switched to tag” markers and throw descriptive TagSwitchError on failure  \n• Implemented centralized handleCliResponse() utility providing fallback parsing, structured logging, and metrics on mismatched formats  \n• Updated TagCommands.selectTag/quickSwitchTag to request text mode and rely on TagService for parsed results; added unit tests covering varied CLI outputs and malformed tables\n</info added on 2025-06-18T12:16:48.584Z>",
            "status": "done",
            "testStrategy": "Component tests for correct rendering, option population, focus/keyboard support, and event emission."
          },
          {
            "id": 4,
            "title": "Integrate Tag Selector with Task Rendering & Edge-Case Handling",
            "description": "Wire the UI component to filtering logic so task list dynamically updates, and provide user feedback when no tasks exist for a tag.",
            "dependencies": [
              2,
              3
            ],
            "details": "• Subscribe task list UI to filterTasksByTag(currentSelectedTag).\n• Display an informative empty-state message when the returned list length is 0.\n• Maintain previous scroll position or reset appropriately on tag change.\n• Debounce rapid tag changes to prevent unnecessary renders.",
            "status": "done",
            "testStrategy": "E2E tests simulating tag switches; verify task list updates correctly and empty-state message appears as needed."
          },
          {
            "id": 5,
            "title": "Comprehensive Testing, Performance Tuning & Documentation",
            "description": "Finalize feature with integrated tests, performance profiling, and developer/user documentation.",
            "dependencies": [
              4
            ],
            "details": "• Run regression and cross-browser tests.\n• Profile filtering/rendering with large datasets; optimize memoization or virtualization if needed.\n• Update README/Help screens with tag-switching instructions.\n• Conduct code review & merge.",
            "status": "done",
            "testStrategy": "Automated CI pipeline executing all unit, component, and E2E suites; manual UX walkthrough to confirm smooth interaction."
          }
        ]
      },
      {
        "id": 13,
        "title": "Add Update Task Option to Task Menu",
        "description": "Integrate an option in the task menu to update existing tasks.",
        "details": "To add the update task functionality to the task menu, first modify the task menu interface to include a new option labeled 'Update Task'. This option should be accessible when a task is selected. Upon selection, present the user with a form pre-filled with the current task details, allowing them to edit fields such as title, description, and dependencies. Ensure that changes are validated and saved correctly to the task management system. Update the task rendering logic to reflect any changes immediately. Consider implementing a confirmation dialog to prevent accidental updates. Additionally, ensure that the update operation is logged for audit purposes.",
        "testStrategy": "1. Verify that the 'Update Task' option appears in the task menu when a task is selected.\n2. Test the update form to ensure it is pre-filled with the correct task details and allows editing.\n3. Validate that changes are saved correctly and reflected in the task view immediately.\n4. Check for the presence of a confirmation dialog before saving changes.\n5. Ensure that update operations are logged correctly for auditing purposes.",
        "status": "done",
        "dependencies": [
          6,
          11
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Add 'Update Task' entry to task menu UI",
            "description": "Extend the task menu component so that, when a task row/card is right-clicked or otherwise selected, an additional menu item labelled 'Update Task' appears.",
            "dependencies": [],
            "details": "• Modify the menu component definition (e.g., TaskMenu.tsx) to inject a new MenuItem.\n• Gate its visibility by whether a valid taskId is in context.\n• Wire the click handler to emit an 'open-update-task' event (or route change) with the selected task’s ID.",
            "status": "done",
            "testStrategy": "Unit: Render menu with/without selected task and assert presence of item. UI: Simulate click and verify navigation/event."
          },
          {
            "id": 5,
            "title": "Comprehensive testing and QA handoff",
            "description": "Write automated tests, perform cross-browser checks, and update documentation for the new update flow.",
            "dependencies": [
              4
            ],
            "details": "• Add Cypress/Playwright E2E covering the happy path, validation errors, cancellation, and audit log creation.\n• Verify accessibility (keyboard navigation, ARIA labels).\n• Update user guide/README.\n• Prepare changelog entry.",
            "status": "done",
            "testStrategy": "Run full test suite in CI. QA smoke test on staging with different roles and screen sizes."
          }
        ]
      },
      {
        "id": 14,
        "title": "Add Analyze Complexity Button",
        "description": "Integrate a button to run the analyze-complexity function next to the add task button in the task management interface.",
        "details": "To implement the analyze-complexity button, first update the task management interface to include a new button labeled 'Analyze Complexity' adjacent to the existing 'Add Task' button. This button should trigger the analyze-complexity function, which evaluates the complexity of tasks based on predefined criteria such as task dependencies, estimated time, and resource requirements. Ensure the function is integrated seamlessly with the existing task management system and that it provides feedback to the user, such as a complexity score or a detailed report. Update the UI to display the results in a user-friendly manner, possibly using a modal or a dedicated section in the task view. Consider performance implications and ensure the function executes efficiently without significant delay.",
        "testStrategy": "1. Verify the 'Analyze Complexity' button is visible and correctly positioned next to the 'Add Task' button.\n2. Test the button functionality by clicking it and ensuring it triggers the analyze-complexity function.\n3. Validate that the complexity analysis results are displayed correctly and are accurate based on known task data.\n4. Check the performance of the complexity analysis to ensure it completes within an acceptable time frame without degrading the UI responsiveness.",
        "status": "done",
        "dependencies": [
          11,
          12
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Expose analyze-complexity API endpoint",
            "description": "Ensure the analyze-complexity function is available to the frontend via a REST (or GraphQL) endpoint that returns a structured complexity report.",
            "dependencies": [],
            "details": "• Review existing analyze-complexity implementation and move any synchronous logic to an async service if needed.\n• Define request/response schema (e.g., POST /api/tasks/complexity => { score:number, breakdown:{…} }).\n• Add input validation (task IDs, project scope).\n• Return HTTP 202 with polling or HTTP 200 depending on expected latency (<1 s vs >1 s).\n• Write unit tests for edge cases (no tasks, circular dependencies, large task sets).",
            "status": "done",
            "testStrategy": "Mock a variety of task lists and assert correct status codes and JSON schema using automated tests (Jest, pytest, etc.)."
          },
          {
            "id": 2,
            "title": "Add 'Analyze Complexity' button to task management UI",
            "description": "Insert a new button adjacent to the existing 'Add Task' button in the toolbar/header of the task management view.",
            "dependencies": [
              1
            ],
            "details": "• Update the UI component (e.g., Toolbar.jsx / TaskHeader.vue) to include a <Button>Analyze Complexity</Button> element.\n• Apply consistent styling, iconography, and tooltips per design system.\n• Ensure button is disabled when there are no tasks or while an analysis request is in flight.",
            "status": "done",
            "testStrategy": "Render component in Storybook; verify visual placement and disabled state toggling with unit tests."
          },
          {
            "id": 3,
            "title": "Implement click handler and API integration",
            "description": "Wire the new button’s onClick event to call the analyze-complexity endpoint and handle asynchronous states.",
            "dependencies": [
              2
            ],
            "details": "• Create useAnalyzeComplexity hook/service that sends the API request (axios/fetch) and returns {loading, data, error}.\n• Show a spinner or progress bar while loading.\n• Gracefully handle API errors (e.g., toast notification with retry option).\n• Cache recent results to avoid duplicate calls within same session if tasks unchanged.",
            "status": "done",
            "testStrategy": "Mock API with success & failure responses; assert UI state transitions using integration tests (React Testing Library/Vue Test Utils)."
          },
          {
            "id": 4,
            "title": "Design and integrate complexity results display",
            "description": "Create a modal or dedicated pane that presents the complexity score and detailed breakdown returned by the API.",
            "dependencies": [
              3
            ],
            "details": "• Build ComplexityReport component: header (overall score), table/chart for breakdown (dependencies count, estimated hours, resources).\n• Highlight high-risk metrics with color coding.\n• Allow users to close, re-run analysis, or export report (PDF/CSV placeholder).\n• Ensure accessibility (focus trapping, ARIA labels) and responsive design.",
            "status": "done",
            "testStrategy": "Visual regression tests with multiple data sets; Lighthouse accessibility audit."
          },
          {
            "id": 5,
            "title": "Performance, UX polish, and regression testing",
            "description": "Optimize API execution time, finalize UI/UX details, and ensure new features do not break existing functionality.",
            "dependencies": [
              4
            ],
            "details": "• Profile backend function; add indexing or in-memory caching if average response >1 s.\n• Lazy-load heavy chart libraries.\n• Conduct cross-browser testing and verify mobile responsiveness.\n• Update end-to-end tests (Cypress/Playwright) covering add task + analyze flow.\n• Update documentation and release notes.",
            "status": "done",
            "testStrategy": "Run load tests with various task volumes; execute full regression test suite in CI and compare baseline performance metrics."
          }
        ]
      },
      {
        "id": 15,
        "title": "Implement CLI Integration Tests",
        "description": "Develop integration tests for the Task Master CLI to automate testing without manual packaging.",
        "details": "To implement CLI integration tests, create a test suite using a testing framework like Mocha or Jest. These tests should execute the Task Master CLI commands, such as 'task-master list --with-subtasks --json', using Node.js's ChildProcess module. Capture and parse the CLI output to verify that the commands produce the expected results. Ensure that the tests cover various scenarios, including edge cases and error handling. Mock any external dependencies to isolate the CLI's functionality during testing. Additionally, set up a continuous integration pipeline to run these tests automatically on each commit.",
        "testStrategy": "1. Set up a testing environment with Mocha or Jest.\n2. Write test cases to execute CLI commands and capture their output.\n3. Verify that the output matches expected results for various scenarios, including normal operations and edge cases.\n4. Mock external dependencies to ensure tests focus on CLI functionality.\n5. Integrate the test suite into a CI pipeline to ensure tests run automatically on each commit.",
        "status": "done",
        "dependencies": [
          2
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 16,
        "title": "Prompt User for Research Option in Analyze Complexity",
        "description": "Enhance the analyze-complexity function to prompt users for research options before execution.",
        "details": "To implement this feature, modify the analyze-complexity function to include a user prompt that asks whether they want to conduct additional research related to the complexity analysis. This prompt should appear immediately after the user initiates the analyze-complexity function via the interface. If the user opts for research, provide options or links to relevant resources or tools that can assist in understanding or mitigating task complexity. Ensure the prompt is non-intrusive and integrates smoothly with the existing UI. Consider using a modal dialog or a notification banner for the prompt. Update the function logic to handle user responses appropriately, proceeding with the analysis if the user declines research.",
        "testStrategy": "1. Trigger the analyze-complexity function and verify that a prompt appears asking the user if they want to conduct research.\n2. Test the user interface to ensure the prompt is clear and provides actionable options for research.\n3. Validate that selecting 'Yes' for research provides appropriate resources or links.\n4. Ensure that selecting 'No' proceeds with the complexity analysis without interruption.\n5. Check that the prompt integrates seamlessly with the existing UI and does not disrupt the user experience.",
        "status": "done",
        "dependencies": [
          14
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Design User Prompt for Research Option",
            "description": "Create a user prompt that asks whether the user wants to conduct additional research related to the complexity analysis.",
            "dependencies": [],
            "details": "The prompt should be clear and concise, informing users about the option to access additional resources or tools to understand or mitigate task complexity. Ensure the language is user-friendly and aligns with the overall tone of the application.",
            "status": "done",
            "testStrategy": "Conduct usability testing to ensure the prompt is easily understood and effectively communicates the research option to users."
          },
          {
            "id": 2,
            "title": "Select Appropriate UI Component for Prompt Display",
            "description": "Choose a suitable UI component, such as a modal dialog or notification banner, to display the user prompt.",
            "dependencies": [
              1
            ],
            "details": "Evaluate the pros and cons of using modal dialogs versus notification banners. Modal dialogs are effective for capturing user attention but can be intrusive, while notification banners are less disruptive but may be overlooked. Consider the user experience and the importance of the prompt in the workflow.",
            "status": "done",
            "testStrategy": "A/B test different UI components to determine which one provides the best balance between visibility and user experience."
          },
          {
            "id": 3,
            "title": "Integrate User Prompt into analyze-complexity Function",
            "description": "Modify the analyze-complexity function to include the user prompt immediately after initiation.",
            "dependencies": [
              2
            ],
            "details": "Ensure that the prompt appears seamlessly after the user initiates the analyze-complexity function. The integration should not disrupt the existing workflow and should provide a smooth user experience.",
            "status": "done",
            "testStrategy": "Perform integration testing to verify that the prompt appears at the correct time and does not cause any disruptions or errors in the function's execution."
          },
          {
            "id": 4,
            "title": "Provide Relevant Research Resources Based on User Response",
            "description": "Offer options or links to relevant resources or tools if the user opts for additional research.",
            "dependencies": [
              3
            ],
            "details": "Curate a list of high-quality resources that can assist users in understanding or mitigating task complexity. Ensure that the resources are up-to-date and relevant to the user's needs.",
            "status": "done",
            "testStrategy": "Validate the relevance and accessibility of the provided resources through user feedback and regular reviews."
          },
          {
            "id": 5,
            "title": "Handle User Responses Appropriately",
            "description": "Update the function logic to proceed with the analysis if the user declines research, or to display resources if the user accepts.",
            "dependencies": [
              4
            ],
            "details": "Implement logic to handle both user responses: continue with the complexity analysis if the user declines additional research, or display the curated resources if the user accepts. Ensure that the transition between these states is smooth and intuitive.",
            "status": "done",
            "testStrategy": "Conduct end-to-end testing to ensure that the function behaves correctly based on different user responses and that the user experience remains consistent."
          }
        ]
      },
      {
        "id": 17,
        "title": "Enable Right-Click Menu on Subtasks",
        "description": "Implement a right-click context menu for subtasks in the task-management interface that lets users update details, change status, and remove a subtask. All persistence is handled locally through the task-master CLI data layer—there is no separate backend API.\n\nUPDATED STATUS (2024-06-11):\n• Right-click (contextmenu) interception on subtask elements is complete and merged (#17.1).\n• Custom context-menu UI with three actions (Update, Change Status, Remove) is fully implemented (#17.2).\n• Commands are registered in package.json and correctly wired to CLI services (#17.3).\n• Validation, error handling, and data persistence through TaskManagerService / TaskOperationsService confirmed via smoke tests.\n\nREMAINING WORK:\n1. Style & accessibility polish for the menu (high-contrast variables, focus ring, keyboard interaction edge cases).\n2. Robust cross-browser verification—including touch/long-press on supported devices—and formal accessibility validation (ARIA, screen-reader flows).\n3. Regression test pass to ensure no viewport-collision or dismissal issues.\n\nAll subsequent development must focus exclusively on UI/UX refinement, accessibility, and testing. Re-implementation of completed functionality is out of scope.",
        "status": "done",
        "dependencies": [
          13
        ],
        "priority": "medium",
        "details": "Implementation guidance for remaining tasks:\n\n• Styling: Ensure the .tm-context-menu follows design-system spacing (8-pt grid) and leverages CSS custom properties defined in theme-helpers.css. Provide explicit focus outline (2px solid var(--tm-focus-border)).\n• Accessibility: The menu element must keep role=\"menu\" with menuitem roles on children. Confirm ArrowUp/ArrowDown cycling, Home/End shortcuts, Enter/Space activation, and Esc dismissal with focus return.\n• Viewport collision: Current util.resizeToFit handles most cases—add unit tests for min-height scenarios and RTL layouts.\n• Browser matrix: Chrome ≥113, Firefox ≥111, Safari ≥16, Edge ≥113 on desktop; Chrome/Firefox on Android and Safari on iPadOS with external keyboard.\n• Error surfacing: The service layer already returns typed errors; surface them via toast notifications (toast.error) without console noise.\n• Touch: Verify long-press shows the same menu on touch devices (TreeView already sends contextmenu event after 500 ms long-press in VS Code 1.83+).\n\nNo additional business logic changes are required—focus on polish and compliance.",
        "testStrategy": "1. Visual & behavioral validation\n   a. Right-click on any subtask: custom menu appears, native menu suppressed.\n   b. Verify Update, Change Status, and Remove all function (already pass smoke tests).\n\n2. Accessibility\n   a. Navigate entire menu using keyboard—Tab to first item, Arrow keys cycle, Home/End jump, Enter/Space activates, Esc closes and restores focus.\n   b. Screen-reader (NVDA, VoiceOver, JAWS) announces menu role and each item label.\n\n3. Styling & theming\n   a. High-contrast themes: check contrast ≥4.5:1 for text and focus indicators.\n   b. Verify focus ring visibility on Windows High Contrast and macOS Increase Contrast.\n\n4. Viewport & positioning\n   a. Open menu near all four viewport edges and corners—menu must reposition to stay fully visible.\n   b. Test <400 px height window and RTL layout.\n\n5. Cross-browser & device matrix\n   a. Desktop: Chrome, Firefox, Safari, Edge (latest two major versions).\n   b. Touch: Chrome on Android 14 tablet, Safari on iPadOS 17; confirm long-press opens menu.\n\n6. Regression\n   a. Rapid open/close cycles (double-right-click) should not leave orphaned DOM nodes.\n   b. Ensure no console errors or unhandled promise rejections during all scenarios.",
        "subtasks": [
          {
            "id": 1,
            "title": "Intercept right-click events on subtask elements",
            "status": "done"
          },
          {
            "id": 2,
            "title": "Build custom context menu with Update, Change Status, and Remove actions",
            "status": "done",
            "details": "<info added on 2025-06-19T15:16:38.288Z>\nGoal\nCreate a clear, user-friendly context menu that appears when the user right-clicks a subtask.\n\nAcceptance Criteria\n• Context menu pops up at the cursor position on right-click.  \n• Options shown:  \n  – Rename / Edit  \n  – Change Status ▸ (Todo, In-Progress, Done)  \n  – Delete  \n• Menu closes when the user clicks elsewhere, presses Esc, or selects an option.  \n• Keyboard support: arrow keys to navigate, Enter to confirm, Esc to cancel.  \n• Use semantic HTML (ul/li) with role=\"menu\"/role=\"menuitem\" plus ARIA-labels for accessibility.  \n• Style matches existing dark theme; z-index keeps menu above other elements.  \n• No page scroll jump or text selection should occur when the menu opens.\n\nImplementation Notes\n1. Add ContextMenu.tsx component that receives (x, y, subtaskId) props.  \n2. Mount the component via a Portal to body to avoid clipping in nested containers.  \n3. Persist menu state in UI store (Redux/Context) so only one menu can be open.  \n4. Clean up event listeners on unmount to prevent memory leaks.  \n5. Provide unit tests for open/close logic and keyboard navigation.\n</info added on 2025-06-19T15:16:38.288Z>"
          },
          {
            "id": 3,
            "title": "Wire menu actions to task-master CLI (update, status change, delete)",
            "status": "done"
          },
          {
            "id": 4,
            "title": "Style menu and ensure accessibility compliance",
            "status": "done"
          }
        ]
      },
      {
        "id": 18,
        "title": "Add Fix Subtasks Action to Task Menu",
        "description": "Implement an action in the task menu to fix subtask IDs by converting them from a string format with parent ID to a simple numeric ID.",
        "details": "To implement the 'Fix Subtasks' action in the task menu, first update the task menu interface to include a new option labeled 'Fix Subtasks'. This option should be available when a task with subtasks is selected. Upon selection, the system should iterate through the subtasks of the selected task, identify any subtasks with IDs in the format 'parentID.subtaskID', and convert these to a simple numeric format by removing the parent ID prefix. Ensure that the changes are persisted correctly in the task management system and that the task rendering logic is updated to reflect these changes immediately. Consider edge cases such as duplicate subtask IDs after conversion and handle them appropriately.",
        "testStrategy": "1. Verify that the 'Fix Subtasks' option appears in the task menu when a task with subtasks is selected.\n2. Test the functionality by selecting the option and ensuring that subtask IDs are converted from 'parentID.subtaskID' to a simple numeric format.\n3. Validate that the changes are saved correctly and reflected in the task view immediately.\n4. Check for edge cases such as duplicate subtask IDs after conversion and ensure they are handled correctly.",
        "status": "done",
        "dependencies": [
          13,
          17
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 19,
        "title": "Enforce Minimum CLI Version Requirement",
        "description": "Prevent the extension from running if the Task Master AI CLI version is below 17.",
        "details": "To implement this feature, modify the initialization routine of the extension to include a version check for the Task Master AI CLI. Use the CLI's version command to retrieve the current version number. Compare this version against the minimum required version (17). If the current version is below 17, display an error message to the user and prevent further execution of the extension. Ensure that the error message is clear and provides instructions on how to update the CLI to the required version. Consider edge cases such as the CLI not being installed or the version command failing, and handle these scenarios gracefully by providing appropriate feedback to the user.",
        "testStrategy": "1. Simulate environments with different CLI versions and verify that the extension runs only when the version is 17 or higher.\n2. Test the error message display when the CLI version is below 17, ensuring it is clear and informative.\n3. Verify that the extension does not execute any further operations when the version check fails.\n4. Test scenarios where the CLI is not installed or the version command fails, ensuring appropriate error handling and user feedback.",
        "status": "done",
        "dependencies": [
          15
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement CLI Version Check in Extension Initialization",
            "description": "Modify the extension's initialization routine to include a check for the Task Master AI CLI version.",
            "dependencies": [],
            "details": "Update the extension's startup sequence to execute a version check command for the Task Master AI CLI. Ensure that the command retrieves the current CLI version accurately.",
            "status": "done",
            "testStrategy": "Unit test the initialization routine to confirm that the version check command executes correctly and retrieves the expected version number."
          },
          {
            "id": 2,
            "title": "Compare Retrieved CLI Version Against Minimum Requirement",
            "description": "Develop logic to compare the retrieved CLI version with the minimum required version (17).",
            "dependencies": [
              1
            ],
            "details": "Implement a function that parses the retrieved CLI version and compares it to the minimum required version. If the current version is below 17, set a flag to prevent further execution of the extension.",
            "status": "done",
            "testStrategy": "Create test cases with various CLI versions to verify that the comparison logic correctly identifies versions below and above the minimum requirement."
          },
          {
            "id": 3,
            "title": "Handle Error Scenarios and Provide User Feedback",
            "description": "Ensure the extension handles scenarios where the CLI is not installed or the version command fails, and provide clear error messages to the user.",
            "dependencies": [
              2
            ],
            "details": "Implement error handling to catch cases where the CLI is missing or the version command fails. Display an error message informing the user of the issue and provide instructions on how to install or update the CLI to meet the minimum version requirement.\n<info added on 2025-06-19T17:20:27.316Z>\nIntegrated initialization guards and unified the command-registration logic so that each CLI command is registered only once. This eliminates the “taskMaster.selectTag already exists” conflict observed during version validation and prevents any future duplicate-registration errors.\n</info added on 2025-06-19T17:20:27.316Z>",
            "status": "done",
            "testStrategy": "Simulate scenarios where the CLI is absent or the version command fails, and verify that the extension displays appropriate error messages and prevents further execution."
          }
        ]
      },
      {
        "id": 20,
        "title": "Implement Right-Click Context Menu for .txt Files to Trigger parse-prd Command",
        "description": "Enable a right-click context-menu entry for .txt files directly inside the operating-system File Explorer (e.g., Windows Explorer, Finder, Nautilus) that executes the parse-prd command with specified options.",
        "status": "done",
        "dependencies": [
          17,
          19
        ],
        "priority": "high",
        "details": "This feature must register a shell / Finder / file-manager extension so that when a user right-clicks any .txt file in their native File Explorer, a menu item labelled “Generate tasks with parse-prd” (or similar) is shown. Selecting that entry must:\n1. Launch the existing parse-prd CLI with the absolute path of the selected file as its first argument.\n2. Accept an optional parameter for the number of tasks to generate (defaulting to 10 if not provided). The UI should prompt the user for this value (e.g., via a small dialog) before invoking the command, or read a default from user settings.\n3. Capture stdout/stderr, surface progress, completion state, and any error messages back to the user (either through a notification toast or a minimal results window).\n\nImplementation notes:\n• Windows: add the context menu by creating a registry entry or packaged COM shell extension.\n• macOS: use a Finder Sync or Quick Actions extension (if support added later).\n• Linux desktop managers: rely on .desktop files or Nautilus/Nemo scripts (future work).\n• All command invocations must be sanitised to avoid command-injection vulnerabilities; escape or quote file paths appropriately.\n\nSecurity: Validate that the selected file really has a .txt extension, that only one file path is passed, and that no additional user-provided arguments are forwarded unchecked.",
        "testStrategy": "1. In the (native) File Explorer, right-click a .txt file and verify a new context-menu item labelled correctly appears.\n2. Click the item and confirm that parse-prd runs with the selected file path. Use a debugger or log to capture the exact command string.\n3. Execute with and without specifying --num-tasks to verify the default (10) and custom values work.\n4. Confirm UI feedback: progress indicator, success message with results, and graceful error handling if parse-prd fails.\n5. Perform security testing: attempt paths with special characters, spaces, and crafted inputs to ensure no command-injection or privilege-escalation issues.\n6. Regression-test existing CLI behaviour to ensure no breaking changes were introduced.",
        "subtasks": [
          {
            "id": 1,
            "title": "Research Methods to Add Context Menu Items for .txt Files",
            "description": "Investigate various approaches to add a right-click context menu option specifically for .txt files in Windows File Explorer.",
            "dependencies": [],
            "details": "Explore methods such as modifying the Windows Registry or using package extensions in the application manifest to add context menu items for .txt files.\n<info added on 2025-06-20T12:20:20.385Z>\nAfter investigation, confirmed that context-menu integration should target the VS Code Explorer, not the native OS shell. Use the “explorer/context” contribution point in package.json to add a right-click command for .txt files, ensuring the command appears only within VS Code’s file explorer and aligns with existing Task Master workflows.\n</info added on 2025-06-20T12:20:20.385Z>",
            "status": "done",
            "testStrategy": "Verify the feasibility and security implications of each method through documentation review and small-scale testing."
          },
          {
            "id": 2,
            "title": "Implement Context Menu Option for .txt Files",
            "description": "Add a right-click context menu option to .txt files that triggers the parse-prd command.",
            "dependencies": [
              1
            ],
            "details": "Based on the chosen method from the research, implement the context menu option that, when selected, executes the parse-prd command with the selected .txt file as input.",
            "status": "done",
            "testStrategy": "Test the context menu option to ensure it appears correctly and triggers the parse-prd command with the correct file path."
          },
          {
            "id": 3,
            "title": "Modify parse-prd Command to Accept Optional Parameter for Number of Tasks",
            "description": "Update the parse-prd command to accept an optional parameter specifying the number of tasks to generate, defaulting to 10 if not specified.",
            "dependencies": [],
            "details": "Enhance the parse-prd command-line interface to include an optional --num-tasks parameter, allowing users to specify the number of tasks to generate.",
            "status": "done",
            "testStrategy": "Test the parse-prd command with and without the --num-tasks parameter to ensure it generates the correct number of tasks."
          },
          {
            "id": 4,
            "title": "Integrate parse-prd Command Execution with Existing CLI",
            "description": "Ensure the parse-prd command is executed through the existing command-line interface, handling any output or errors appropriately.",
            "dependencies": [
              2,
              3
            ],
            "details": "Utilize the existing CLI integration to execute the parse-prd command when the context menu option is selected, capturing and displaying any output or errors.",
            "status": "done",
            "testStrategy": "Test the integration by selecting the context menu option and verifying that the parse-prd command executes correctly, with output and errors handled as expected."
          },
          {
            "id": 5,
            "title": "Update UI to Reflect Command Execution Status and Results",
            "description": "Modify the user interface to display the status and results of the parse-prd command execution initiated from the context menu.",
            "dependencies": [
              4
            ],
            "details": "Implement UI elements that provide feedback to the user regarding the execution status and results of the parse-prd command, such as progress indicators and result summaries.",
            "status": "done",
            "testStrategy": "Test the UI updates by executing the parse-prd command through the context menu and verifying that the status and results are displayed correctly."
          }
        ]
      },
      {
        "id": 21,
        "title": "Add Workspace Support for Task-Master Configuration",
        "description": "Enhance the extension so that it can intelligently detect whether the user has opened a single-folder repository or a multi-root VSCode workspace.  In workspace mode the UI tree must add a repository-level grouping that aggregates and displays all tasks (including *Current* and *Next*) under the corresponding repo node.  After context detection the extension must locate and apply an authoritative .taskmaster configuration using the rules below.",
        "status": "pending",
        "dependencies": [
          11,
          17
        ],
        "priority": "high",
        "details": "Task-Master currently looks for a configuration folder inside each individual repository and renders a global task tree.  With true workspace support we now need two parallel enhancements:\n\nA. Context & configuration lookup (previous requirement, unchanged in spirit)\n------------------------------------------------------------\n1. Detect context\n   • Multi-root workspace: treat the workspace file (.code-workspace) as the top-level context.\n   • Single-folder: treat the opened folder as both workspace and repository.\n\n2. Configuration search strategy\n   a. Multi-root workspace: look for a .taskmaster folder at workspace root.  If present, apply it to all repos; otherwise fall back to per-repo configs.\n   b. Single-folder: look only inside the opened folder for .taskmaster.\n\n3. Precedence: workspace-level config > repo-level config > extension defaults.\n\n4. Edge cases still apply (multiple configs, dynamic folder add/remove, etc.).\n\nB. Tree-view re-architecture (NEW requirement)\n------------------------------------------------------------\n1. When the extension detects workspace mode, the Task Tree view must introduce an additional level: Repository node ➞ {Current | Next | All Tasks | custom groups}.\n2. Each repo node aggregates tasks belonging to that folder only; workspace-level commands may still operate on every repo under the hood.\n3. Single-folder mode keeps the existing flat tree for backward compatibility.\n4. The provider must react to dynamic workspace changes (folder addition/removal) and update the repo nodes in real-time.\n5. Telemetry/logging: emit diagnostics when tasks cannot be mapped to a repo node.\n6. Documentation & examples must illustrate the new tree structure side-by-side with configuration precedence rules.",
        "testStrategy": "1. Single-folder mode\n   • Open a lone repository with its own .taskmaster folder.\n   • Verify the tree view contains no repository wrapper node and the existing structure remains intact.\n\n2. Workspace mode with workspace-level config\n   • Create a workspace containing three Git folders plus a .taskmaster folder at workspace root.\n   • Confirm that a repo node appears for each folder and that Current/Next/All Tasks underneath each node reflect the workspace-level config.\n\n3. Workspace mode without workspace-level config\n   • Remove the root config and place .taskmaster folders in two repos only.\n   • Ensure each of those two repos show their respective tasks while the third repo falls back to defaults.\n\n4. Conflict precedence\n   • Put both workspace-level and repo-level configs for one repo.\n   • Verify workspace config wins; a warning should appear and the tree reflects workspace settings.\n\n5. Dynamic workspace update\n   • Add and remove folders while VSCode is running.  Confirm repo nodes are added/removed and inherit the correct tasks instantly.\n\n6. UI regression\n   • Snapshot test the tree provider to guarantee deterministic ordering and hierarchy.\n\n7. Manual smoke tests on Windows/macOS/Linux for path handling, workspace detection, and tree rendering (light/dark themes, accessibility, collapsible states).",
        "subtasks": [
          {
            "id": 1,
            "title": "Refactor Task Tree provider to support repository-level root nodes in workspace mode",
            "status": "pending"
          },
          {
            "id": 2,
            "title": "Implement task aggregation logic per repository and wire Current/Next views under each repo node",
            "status": "pending"
          },
          {
            "id": 3,
            "title": "Update context detector to notify tree provider when switching between single-folder and workspace modes",
            "status": "pending"
          },
          {
            "id": 4,
            "title": "Add unit & integration tests for new tree hierarchy and dynamic workspace changes",
            "status": "pending"
          },
          {
            "id": 5,
            "title": "Update documentation and screenshots to illustrate repository-level tree structure and configuration precedence",
            "status": "pending"
          }
        ]
      },
      {
        "id": 22,
        "title": "Implement Subtask Management CLI Commands",
        "description": "Develop CLI commands to manage subtasks, including adding, converting, removing, and clearing subtasks, with optional support for operating within a VS Code workspace file.",
        "status": "pending",
        "dependencies": [
          11,
          18
        ],
        "priority": "high",
        "details": "Implement the following CLI commands for subtask management. Each command now accepts an optional `--workspace=<path/to/workspace.code-workspace>` parameter that, when supplied, limits all operations to tasks contained in the specified VS Code workspace file. When omitted, the commands operate on the current/default workspace as previously defined.\n\n1. `add-subtask --parent=<id> --title=\"<title>\" [--description=\"<desc>\"] [--workspace=<file>]`: Add a new subtask to a specified parent task within the chosen workspace.\n\n2. `add-subtask --parent=<id> --task-id=<id> [--workspace=<file>]`: Convert an existing task into a subtask of a specified parent task. Works across workspaces; if the parent and child belong to different workspaces, raise a validation error unless an explicit `--force-cross-workspace` flag (to be considered in later iterations) is added.\n\n3. `remove-subtask --id=<parentId.subtaskId> [--convert] [--workspace=<file>]`: Remove a subtask from a parent task. If `--convert` is used, convert the subtask into a standalone task (still within the same workspace unless overridden).\n\n4. `clear-subtasks --id=<id> [--workspace=<file>]`: Remove all subtasks from a specified task within the chosen workspace.\n\n5. `clear-subtasks --all [--workspace=<file>]`: Remove all subtasks from all tasks. If `--workspace` is provided, restrict the operation to that workspace; otherwise it applies globally across workspaces.\n\nEnsure that:\n• The task management system persists workspace information on every update.\n• Appropriate errors are shown for invalid or missing workspace files, or when attempting to manipulate tasks across different workspaces without permission.\n• Legacy behaviour (no `--workspace`) remains backward-compatible.\n\nEdge cases to consider include non-existent parent tasks, converting an already-subtask task, and referencing workspace files that cannot be located or parsed.",
        "testStrategy": "1. Test `add-subtask` with and without the `--workspace` flag; verify the subtask appears in the correct workspace hierarchy.\n2. Convert an existing task into a subtask within the same workspace and across different workspaces; confirm correct validation behaviour.\n3. Validate `remove-subtask` with and without `--convert`, ensuring the target workspace file is updated appropriately.\n4. Use `clear-subtasks --id=<id>` on a task in a workspace file and verify all subtasks are removed only from that workspace.\n5. Execute `clear-subtasks --all --workspace=<file>` and confirm subtasks are removed exclusively from the specified workspace; run again without `--workspace` and confirm removal across all workspaces.\n6. Test invalid workspace paths or corrupted `.code-workspace` files and verify informative error messages are displayed.\n7. Regression tests: run original commands without the new flag to ensure backward compatibility and unchanged behaviour in the default workspace.",
        "subtasks": [
          {
            "id": 1,
            "title": "Design CLI Command Specifications",
            "description": "Define the syntax, required parameters, optional flags (including `--workspace`), and expected outputs for each subtask management command.",
            "dependencies": [],
            "details": "Update and finalise specifications for `add-subtask`, `remove-subtask`, and `clear-subtasks`, incorporating the new optional `--workspace` parameter and documenting its behaviour, defaults, and limitations.",
            "status": "pending",
            "testStrategy": "Develop unit tests that validate the correctness of command specifications—ensuring the parser accepts valid combinations of parameters (with/without `--workspace`) and rejects invalid ones."
          },
          {
            "id": 2,
            "title": "Implement Command Parsing and Validation",
            "description": "Develop the logic to parse user input and validate command parameters for the subtask management commands.",
            "dependencies": [
              1
            ],
            "details": "Enhance input parsing mechanisms to recognise the `--workspace` flag. Validate that provided workspace paths exist and point to readable `.code-workspace` files.",
            "status": "pending",
            "testStrategy": "Create test cases verifying that parsing correctly interprets user input and that validation mechanisms catch invalid parameters or workspace paths."
          },
          {
            "id": 3,
            "title": "Integrate Commands with Task Management System",
            "description": "Connect the parsed and validated commands to the underlying task management system to perform the desired operations.",
            "dependencies": [
              2
            ],
            "details": "Modify data-access layers so that task CRUD operations respect the selected workspace context, persisting changes in the correct workspace file or database namespace.",
            "status": "pending",
            "testStrategy": "Conduct integration tests showing that commands correctly modify task/subtask data in the designated workspace and handle edge cases."
          },
          {
            "id": 4,
            "title": "Implement User Feedback and Error Handling",
            "description": "Provide clear feedback to users upon command execution and handle errors gracefully.",
            "dependencies": [
              3
            ],
            "details": "Update success and error messages to include workspace context where relevant (e.g., \"Subtask added to task 42 in workspace myproj.code-workspace\").",
            "status": "pending",
            "testStrategy": "Simulate various scenarios—including missing workspace, invalid path, and cross-workspace conflicts—and verify that feedback is accurate and helpful."
          },
          {
            "id": 5,
            "title": "Develop Comprehensive Documentation",
            "description": "Create detailed documentation for each subtask management command, including usage examples and troubleshooting tips.",
            "dependencies": [
              4
            ],
            "details": "Document the new `--workspace` option, provide examples for single and multi-workspace usage, and outline best practices for managing subtasks across workspaces.",
            "status": "pending",
            "testStrategy": "Review documentation for accuracy and clarity, and gather user feedback to identify areas for improvement."
          }
        ]
      },
      {
        "id": 23,
        "title": "Standardize VSCode Notifications with Loading Indicators",
        "description": "Enhance VSCode notifications to include standardized loading indicators for long-running tasks such as updating and expanding.",
        "details": "To implement standardized VSCode notifications with loading indicators, first identify all long-running tasks within the extension that currently trigger notifications. Modify these notifications to include a loading indicator using VSCode's `window.withProgress` API. This API allows for the display of a progress indicator in the VSCode UI, which can be either a progress bar or a spinner. Ensure that the loading indicator is displayed at the start of the task and is updated or completed once the task finishes. Additionally, ensure that all notifications follow a consistent format, including a clear title, message, and optional actions. Consider edge cases where tasks may fail or be cancelled, and ensure the loading indicator reflects these states appropriately.",
        "testStrategy": "1. Identify all long-running tasks that trigger notifications and verify that each now includes a loading indicator using the `window.withProgress` API. 2. Simulate long-running tasks and observe the loading indicator's behavior, ensuring it starts, updates, and completes correctly. 3. Test scenarios where tasks fail or are cancelled to ensure the loading indicator reflects these states accurately. 4. Verify that all notifications follow a consistent format with clear titles and messages.",
        "status": "pending",
        "dependencies": [
          21,
          22
        ],
        "priority": "low",
        "subtasks": [
          {
            "id": 1,
            "title": "Identify Long-Running Tasks Triggering Notifications",
            "description": "Review the extension's codebase to pinpoint all long-running tasks that currently trigger notifications, such as updating and expanding operations.",
            "dependencies": [],
            "details": "Examine the extension's source code to locate functions or processes that initiate notifications for tasks expected to take a significant amount of time. Document these tasks for further modification.",
            "status": "pending",
            "testStrategy": "Verify that all identified tasks are correctly listed and that no long-running task triggering a notification is overlooked."
          },
          {
            "id": 2,
            "title": "Implement Loading Indicators Using `window.withProgress` API",
            "description": "Modify the identified notifications to include loading indicators by utilizing VSCode's `window.withProgress` API.",
            "dependencies": [
              1
            ],
            "details": "For each long-running task identified, refactor the notification code to use the `window.withProgress` API. This API allows displaying a progress indicator, such as a spinner or progress bar, in the VSCode UI. Ensure the loading indicator starts at the beginning of the task and updates or completes upon task completion. Handle scenarios where tasks may fail or be canceled, updating the loading indicator accordingly.",
            "status": "pending",
            "testStrategy": "For each modified notification, initiate the corresponding long-running task and confirm that the loading indicator appears at the start, updates appropriately during the task, and disappears upon completion. Test failure and cancellation scenarios to ensure the loading indicator reflects these states correctly."
          },
          {
            "id": 3,
            "title": "Standardize Notification Format",
            "description": "Ensure all notifications follow a consistent format, including a clear title, message, and optional actions.",
            "dependencies": [
              2
            ],
            "details": "Review and update all notifications to adhere to a standardized format. Each notification should have a clear and concise title, an informative message, and, if applicable, actions that the user can take. This standardization enhances user experience and maintains consistency across the extension.",
            "status": "pending",
            "testStrategy": "Trigger each notification and verify that it displays with the standardized title, message, and any applicable actions. Ensure that the format is consistent across all notifications within the extension."
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-06-17T14:01:27.651Z",
      "updated": "2025-06-20T20:18:16.984Z",
      "description": "Tasks for master context"
    }
  }
}