{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Setup Project Repository",
        "description": "Initialize the project repository with necessary configurations and dependencies.",
        "details": "1. Initialize a new Git repository.\n2. Set up TypeScript with ES2022 target.\n3. Install necessary dependencies: VS Code API, Task Master CLI, Node.js.\n4. Configure esbuild for bundling.\n5. Set up GitHub Actions for CI/CD.",
        "testStrategy": "Verify repository setup by checking if all dependencies are installed and the project builds successfully.",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Implement CLI Integration Layer",
        "description": "Develop the integration layer to execute Task Master CLI commands and parse outputs.",
        "details": "1. Use Node.js ChildProcess.spawn to execute 'task-master list --with-subtasks --json'.\n2. Implement stdout streaming and incremental parsing.\n3. Set up debounce polling with a configurable interval.",
        "testStrategy": "Mock CLI responses and verify that the integration layer correctly parses and outputs task data.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Develop Task Tree View",
        "description": "Create a TreeDataProvider to render tasks and subtasks in a hierarchical view.",
        "details": "1. Use VS Code's TreeDataProvider API to create a tree view.\n2. Render tasks with ID, title, status, and complexity score.\n3. Implement collapsible dependency branches.",
        "testStrategy": "Test the tree view with mock data to ensure correct rendering and interactivity.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Add Interactive Node Commands",
        "description": "Extend the VS Code extension so users can fully manage and navigate Task-Master tasks directly from the tree view. In addition to opening PRDs and marking tasks complete, users must be able to add and delete tasks (with dependency handling) and quickly navigate to, or display, the next actionable task or any specific task’s details.",
        "status": "done",
        "dependencies": [
          3
        ],
        "priority": "medium",
        "details": "The tree-view context menu should expose the following commands, all of which must rely on the Task-Master CLI and surface clear progress / error messages to the user.\n\n1. Open PRD – runs `task-master open-prd <id>` or simply opens .taskmaster/docs/prd.txt when the selected node represents the project root.\n2. Show in Terminal – runs `task-master show <id>`.\n3. Mark Complete – runs `task-master complete <id>` then refreshes the tree.\n4. Add Task – opens an input box / quick-pick sequence to collect: title, description, priority, dependencies. When confirmed, run `task-master add --title \"…\" --description \"…\" --priority … --deps …`. Refresh the tree afterwards and reveal the new node.\n5. Delete Task –\n   a. Run `task-master validate-dependencies <id>` to determine if other tasks depend on the target.\n   b. If no dependents, confirm deletion and execute `task-master delete <id>`.\n   c. If dependents exist, show them and prompt the user. On confirmation, automatically run `task-master fix-dependencies --remove <id>` and then `task-master delete <id>`.\n   d. Refresh the tree.\n6. Manage Dependencies (context submenu or command palette):\n   • Add Dependency – `task-master add-dependency <srcId> <depId>`\n   • Remove Dependency – `task-master remove-dependency <srcId> <depId>`\n   • Validate Dependencies – `task-master validate-dependencies <id>` (result surfaced in an information message).\n7. Next Task – runs `task-master next` (optionally scoped to the selected node) and then reveals that task in the tree / opens quick-pick to navigate to it.\n8. Show Task Details – same behaviour as Show in Terminal but displayed in an editor tab or webview for richer formatting.\n\nAll menu commands must be registered in package.json, appear contextually (e.g., Delete only for leaf or confirmed tasks), and be covered by telemetry / logging hooks.",
        "testStrategy": "Manual & automated tests (using vscode-test + mocha):\n1. For each command, verify the correct CLI call is assembled and executed (mock the binary in unit tests).\n2. Confirm the tree view refreshes and reflects changes after add, delete, complete, dependency edits.\n3. For Delete Task, prepare tasks with and without dependents and assert the proper confirmation flow and CLI commands sequence.\n4. Validate UI feedback: information, warning, and error messages appear appropriately, and navigation (reveal node, open webview) works.\n5. Integration smoke test: create a mini project, add several tasks with dependencies, mark some complete, run Next Task multiple times, ensuring ordering matches CLI output.",
        "subtasks": [
          {
            "id": 1,
            "title": "Scaffold new commands in package.json and command registration",
            "status": "done"
          },
          {
            "id": 2,
            "title": "Implement Add Task flow with quick-pick and CLI invocation",
            "status": "done"
          },
          {
            "id": 3,
            "title": "Implement Delete Task with dependency checks and confirmations",
            "status": "done"
          },
          {
            "id": 4,
            "title": "Implement Dependency Management commands (add/remove/validate)",
            "status": "done"
          },
          {
            "id": 5,
            "title": "Implement Next Task navigation and task details viewer",
            "status": "done"
          },
          {
            "id": 6,
            "title": "Write unit tests mocking Task-Master CLI interactions",
            "status": "done"
          },
          {
            "id": 7,
            "title": "End-to-end tests creating, deleting, and navigating tasks",
            "status": "done"
          }
        ]
      },
      {
        "id": 5,
        "title": "Implement Status Bar & Telemetry",
        "description": "Develop a status bar item to display the next actionable task and telemetry data.",
        "details": "1. Create a status bar item using VS Code API.\n2. Display the next task using 'task-master next'.\n3. Show real-time AI token cost for Task Master v0.14 and above.",
        "testStrategy": "Test the status bar updates and telemetry display with both mock and real data.",
        "priority": "medium",
        "dependencies": [
          3
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Create Settings UI",
        "description": "Develop a settings interface that allows users to configure the CLI path and automatically persist the selected cycle view so users retain their preferred view across VS Code sessions.\n\nAll requirements have been fully implemented:\n• The CLI path configuration setting and runtime reading logic are finished and verified.\n• Cycle-view selection now persists via globalState and reliably restores on activation.\n• Legacy settings (refreshInterval, enableTelemetry, autoRefresh, securityLevel) have been entirely removed from the codebase and documentation.\n• A complete regression and quality-assurance pass was executed—TypeScript build, ESLint checks, security validation, and the full package build all passed with no issues.\n\nNo additional work remains.",
        "status": "done",
        "dependencies": [
          3
        ],
        "priority": "medium",
        "details": "1. CLI Path setting (COMPLETED)\n   • Exposed `myExtension.cliPath` string setting in package.json via `contributes.configuration`.\n   • `ConfigService` reads the configured value on demand and listens for configuration-change events so the new path is used without requiring a window reload.\n\n2. Cycle-view persistence (COMPLETED)\n   • `StatusBarService` stores the selected cycle-view identifier in `extensionContext.globalState` whenever the user switches views.\n   • On activation, `extension.ts` passes the extension context to `StatusBarService`, which immediately restores the last stored view.\n\n3. Remove legacy options (COMPLETED)\n   • Deleted `refreshInterval`, `enableTelemetry`, `autoRefresh`, and `securityLevel` settings from package.json.\n   • Updated `TaskMasterConfig` interface, simplified `CLIService`, and removed all telemetry functionality from `StatusBarService`.\n   • README and CHANGELOG updated to reflect the removals.\n   • Verified that the Settings UI no longer shows the obsolete options.\n\n4. Regression and runtime compliance (COMPLETED)\n   • Manual and automated tests executed:\n     – TypeScript compilation: PASSED\n     – ESLint code quality: PASSED (fixed curly-brace warning)\n     – Security validation: PASSED (0 issues, 0 warnings)\n     – Package build: PASSED\n   • Confirmed the extension activates without error in clean workspaces and in workspaces containing stale settings.\n",
        "testStrategy": "All tests completed and passed:\n1. CLI Path\n   • Changing `myExtension.cliPath` in Settings immediately updates the runtime configuration; verified again after window reload.\n2. Cycle View Persistence\n   • Selecting a non-default cycle view and reloading VS Code restores the same view automatically.\n3. Legacy Setting Removal Regression\n   • Obsolete settings no longer appear in the Settings UI; no schema warnings for old keys present in user settings.json.\n   • Extension activates cleanly with and without stale settings present.\n4. Full Extension Smoke Test\n   • Activation succeeds with and without stored cycle-view state.\n   • All commands that rely on `cliPath` execute successfully.\n5. Quality & Security Gates\n   • TypeScript compilation, ESLint linting, security validation, and package build all passed with zero errors or warnings.",
        "subtasks": [
          {
            "id": 1,
            "title": "Add CLI path configuration setting",
            "status": "done",
            "description": "Expose a `myExtension.cliPath` string setting in package.json and read it in the extension."
          },
          {
            "id": 2,
            "title": "Persist selected cycle view",
            "status": "done",
            "description": "Store the chosen cycle view in globalState and restore it on activation."
          },
          {
            "id": 3,
            "title": "Update documentation and remove obsolete settings",
            "status": "done",
            "description": "Clean up references to refresh interval and telemetry in README and package.json."
          },
          {
            "id": 4,
            "title": "Testing & verification",
            "status": "done",
            "description": "Run manual and automated tests to confirm persistence, CLI path behavior, regression after removing obsolete settings, and overall build quality. All tests have passed."
          }
        ]
      },
      {
        "id": 7,
        "title": "Ensure Security and Compliance",
        "description": "Implement security measures and ensure compliance with VS Code marketplace requirements.",
        "details": "1. Follow runtime-security guidelines to restrict network calls.\n2. Declare 'untrustedWorkspaces' limitations.\n3. Ensure package is signed and verify with CI.",
        "testStrategy": "Conduct a security audit and verify compliance with marketplace guidelines.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Support Expand Task Command to Break Task into Subtasks",
        "description": "Implement a feature to allow users to expand a task into multiple subtasks within the extension.",
        "details": "To implement the 'expand task' command, first update the command palette to include a new command 'Expand Task'. This command should prompt the user to select a task to expand. Once a task is selected, provide an interface to define subtasks, including title, description, and dependencies for each subtask. Store these subtasks in the task management system, ensuring they are linked to the parent task. Update the task rendering logic to display subtasks hierarchically under their parent task. Consider using a collapsible tree view for better user experience. Ensure that the task data model supports nesting and that the task persistence layer can handle the new structure.",
        "testStrategy": "1. Verify the 'Expand Task' command appears in the command palette and can be executed.\n2. Test the user interface for creating subtasks, ensuring all fields are functional and data is saved correctly.\n3. Check that subtasks are displayed under their parent task in the task view.\n4. Validate that the task data model correctly represents the hierarchy of tasks and subtasks.\n5. Ensure that the task persistence layer saves and loads tasks with subtasks accurately.\n6. Conduct user testing to ensure the feature is intuitive and meets user needs.",
        "status": "done",
        "dependencies": [
          6
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Implement Tag Switching Functionality",
        "description": "Enable users to switch between different task tags within the extension.",
        "details": "To implement tag switching, first update the task management interface to include a dropdown or similar UI element that lists all available tags. This UI component should allow users to select a tag, which will filter the displayed tasks to only those associated with the selected tag. Ensure that the tag data is stored and retrieved efficiently, possibly using a caching mechanism to improve performance. Additionally, update the task rendering logic to dynamically display tasks based on the selected tag. Consider edge cases such as no tasks being associated with a selected tag and provide appropriate user feedback. Ensure the UI is intuitive and integrates seamlessly with existing task management features.",
        "testStrategy": "1. Verify that the tag switching UI component is visible and functional within the task management interface.\n2. Test the functionality by selecting different tags and ensuring that only tasks associated with the selected tag are displayed.\n3. Check the performance of the tag switching feature, ensuring it operates smoothly without significant delay.\n4. Validate that the system handles cases where no tasks are associated with a selected tag, providing appropriate feedback to the user.",
        "status": "done",
        "dependencies": [
          6,
          11
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Extend Data Model and Caching for Tag Retrieval",
            "description": "Introduce or update data structures so each task stores an associated tag list and the full set of tags can be fetched quickly with caching.",
            "dependencies": [],
            "details": "• Update DB schema / local storage to persist tag ↔︎ task relations.\n• Implement a tag repository/service with an in-memory cache (e.g., Map) that invalidates on task/tag mutation events.\n• Expose async methods: getAllTags(), getTasksByTag(tagId).\n• Ensure fallback to API/local storage when cache miss occurs.\n<info added on 2025-06-18T11:12:37.505Z>\n• Introduced strongly-typed models (TagInfo, TagServiceResponse, TagCacheEntry) to standardise tag payloads across services.  \n• Implemented TagService with a 30 s TTL in-memory cache for getAllTags() and getTasksByTag(), including automatic fallback to API/local storage on cache miss.  \n• Wired TaskCacheService to subscribe to tag events, enabling tag-aware cache refreshes after TASK_UPDATED / TAG_UPDATED mutations.  \n• Exposed tag operations (getAllTags, getTasksByTag, setCurrentTag) through TaskManagerService and the VS Code extension command layer.  \n• Adopted event-driven architecture: TagService emits TAG_CACHE_HIT, TAG_CACHE_MISS, and TAG_CACHE_INVALIDATED events consumed by UI and other services for instant updates.  \n• getAllTags()/getTasksByTag() now resolve to an empty array when no matching tags exist, preventing unhandled errors in consumer code.  \n• Persisted currentTag selection in .taskmaster/config.json, re-loading it on extension startup to restore user context.\n</info added on 2025-06-18T11:12:37.505Z>",
            "status": "done",
            "testStrategy": "Unit-test repository functions with mocked storage to verify cache hits/misses and correct data returns."
          },
          {
            "id": 2,
            "title": "Implement Client-Side Filtering Logic",
            "description": "Create reusable functions/selectors that, given a tag ID, return only the tasks that match, leveraging the caching layer.",
            "dependencies": [
              1
            ],
            "details": "• In state management layer (Redux/Vuex/Context), add currentSelectedTag state.\n• Write filterTasksByTag(tagId) that subscribes to task list updates and memoizes results.\n• Ensure it returns empty array immediately if no tasks match, without throwing errors.\n<info added on 2025-06-18T11:19:54.605Z>\n• Added taskFilterUtils.ts housing a TaskFilterManager singleton that maintains per-tag cache with 5-second TTL and memoized results  \n• filterTasksByTag(tagId) now delegates to TaskFilterManager, aligning with server-side CLI tag switching while providing local caching  \n• Introduced helper functions setCurrentSelectedTag, getCurrentSelectedTag and clearFilterCache; state stays in sync via Tag change events emitted by TaskManagerService  \n• Wired TaskFilterManager into TaskCacheService and TagService for automatic cache warm-up, validation and stale-data invalidation  \n• Exposed getFilterStats utility for debugging cache hit/miss ratios and entry age  \n• Verified empty arrays are returned gracefully for unknown or empty tag queries\n</info added on 2025-06-18T11:19:54.605Z>",
            "status": "done",
            "testStrategy": "Unit tests verifying correct subsets are returned for existing, non-existing, and undefined tag values."
          },
          {
            "id": 3,
            "title": "Create Tag Selector UI Component",
            "description": "Add a dropdown (or segmented control) that lists all available tags and triggers selection events.",
            "dependencies": [
              1
            ],
            "details": "• Build a reusable <TagDropdown /> component.\n• On mount, call getAllTags() to populate options.\n• Emit onTagSelected(tagId) when user chooses a tag.\n• Apply current theme/styles and ensure keyboard accessibility.\n<info added on 2025-06-18T12:12:49.153Z>\n• Added TagCommands class exposing selectTag(), quickSwitchTag(), and showCurrentTagInfo() handlers that open a VS Code QuickPick powered by getAllTags(), emit tag-change events, and invoke CLI commands (tags / use-tag) with robust error handling  \n• Extended StatusBarService with a dynamic tag item showing the active tag and task count; click action launches the TagDropdown  \n• Registered “Select Tag” command, status-bar item, and toolbar button in package.json with theme-aware icons and proper menu placement  \n• Wired event bus so tree view and status bar automatically refresh on tag-change; user receives informational toast notifications  \n• Ensured full keyboard navigation, current-tag highlighting, and theme adherence across QuickPick, toolbar, and status-bar entry\n</info added on 2025-06-18T12:12:49.153Z>\n<info added on 2025-06-18T12:16:48.584Z>\n• Refactored TagService to default “tags” and “use-tag” invocations to --format=text and introduced parseTagsOutput() for decoding ASCII table rows (handles current-tag glyph, column spacing, and metadata columns)  \n• Enhanced setCurrentTag() to scan command stdout for “(current)” or “Switched to tag” markers and throw descriptive TagSwitchError on failure  \n• Implemented centralized handleCliResponse() utility providing fallback parsing, structured logging, and metrics on mismatched formats  \n• Updated TagCommands.selectTag/quickSwitchTag to request text mode and rely on TagService for parsed results; added unit tests covering varied CLI outputs and malformed tables\n</info added on 2025-06-18T12:16:48.584Z>",
            "status": "done",
            "testStrategy": "Component tests for correct rendering, option population, focus/keyboard support, and event emission."
          },
          {
            "id": 4,
            "title": "Integrate Tag Selector with Task Rendering & Edge-Case Handling",
            "description": "Wire the UI component to filtering logic so task list dynamically updates, and provide user feedback when no tasks exist for a tag.",
            "dependencies": [
              2,
              3
            ],
            "details": "• Subscribe task list UI to filterTasksByTag(currentSelectedTag).\n• Display an informative empty-state message when the returned list length is 0.\n• Maintain previous scroll position or reset appropriately on tag change.\n• Debounce rapid tag changes to prevent unnecessary renders.",
            "status": "done",
            "testStrategy": "E2E tests simulating tag switches; verify task list updates correctly and empty-state message appears as needed."
          },
          {
            "id": 5,
            "title": "Comprehensive Testing, Performance Tuning & Documentation",
            "description": "Finalize feature with integrated tests, performance profiling, and developer/user documentation.",
            "dependencies": [
              4
            ],
            "details": "• Run regression and cross-browser tests.\n• Profile filtering/rendering with large datasets; optimize memoization or virtualization if needed.\n• Update README/Help screens with tag-switching instructions.\n• Conduct code review & merge.",
            "status": "done",
            "testStrategy": "Automated CI pipeline executing all unit, component, and E2E suites; manual UX walkthrough to confirm smooth interaction."
          }
        ]
      },
      {
        "id": 13,
        "title": "Add Update Task Option to Task Menu",
        "description": "Integrate an option in the task menu to update existing tasks.",
        "details": "To add the update task functionality to the task menu, first modify the task menu interface to include a new option labeled 'Update Task'. This option should be accessible when a task is selected. Upon selection, present the user with a form pre-filled with the current task details, allowing them to edit fields such as title, description, and dependencies. Ensure that changes are validated and saved correctly to the task management system. Update the task rendering logic to reflect any changes immediately. Consider implementing a confirmation dialog to prevent accidental updates. Additionally, ensure that the update operation is logged for audit purposes.",
        "testStrategy": "1. Verify that the 'Update Task' option appears in the task menu when a task is selected.\n2. Test the update form to ensure it is pre-filled with the correct task details and allows editing.\n3. Validate that changes are saved correctly and reflected in the task view immediately.\n4. Check for the presence of a confirmation dialog before saving changes.\n5. Ensure that update operations are logged correctly for auditing purposes.",
        "status": "done",
        "dependencies": [
          6,
          11
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Add 'Update Task' entry to task menu UI",
            "description": "Extend the task menu component so that, when a task row/card is right-clicked or otherwise selected, an additional menu item labelled 'Update Task' appears.",
            "dependencies": [],
            "details": "• Modify the menu component definition (e.g., TaskMenu.tsx) to inject a new MenuItem.\n• Gate its visibility by whether a valid taskId is in context.\n• Wire the click handler to emit an 'open-update-task' event (or route change) with the selected task’s ID.",
            "status": "done",
            "testStrategy": "Unit: Render menu with/without selected task and assert presence of item. UI: Simulate click and verify navigation/event."
          },
          {
            "id": 5,
            "title": "Comprehensive testing and QA handoff",
            "description": "Write automated tests, perform cross-browser checks, and update documentation for the new update flow.",
            "dependencies": [
              4
            ],
            "details": "• Add Cypress/Playwright E2E covering the happy path, validation errors, cancellation, and audit log creation.\n• Verify accessibility (keyboard navigation, ARIA labels).\n• Update user guide/README.\n• Prepare changelog entry.",
            "status": "done",
            "testStrategy": "Run full test suite in CI. QA smoke test on staging with different roles and screen sizes."
          }
        ]
      },
      {
        "id": 14,
        "title": "Add Analyze Complexity Button",
        "description": "Integrate a button to run the analyze-complexity function next to the add task button in the task management interface.",
        "details": "To implement the analyze-complexity button, first update the task management interface to include a new button labeled 'Analyze Complexity' adjacent to the existing 'Add Task' button. This button should trigger the analyze-complexity function, which evaluates the complexity of tasks based on predefined criteria such as task dependencies, estimated time, and resource requirements. Ensure the function is integrated seamlessly with the existing task management system and that it provides feedback to the user, such as a complexity score or a detailed report. Update the UI to display the results in a user-friendly manner, possibly using a modal or a dedicated section in the task view. Consider performance implications and ensure the function executes efficiently without significant delay.",
        "testStrategy": "1. Verify the 'Analyze Complexity' button is visible and correctly positioned next to the 'Add Task' button.\n2. Test the button functionality by clicking it and ensuring it triggers the analyze-complexity function.\n3. Validate that the complexity analysis results are displayed correctly and are accurate based on known task data.\n4. Check the performance of the complexity analysis to ensure it completes within an acceptable time frame without degrading the UI responsiveness.",
        "status": "done",
        "dependencies": [
          11,
          12
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Expose analyze-complexity API endpoint",
            "description": "Ensure the analyze-complexity function is available to the frontend via a REST (or GraphQL) endpoint that returns a structured complexity report.",
            "dependencies": [],
            "details": "• Review existing analyze-complexity implementation and move any synchronous logic to an async service if needed.\n• Define request/response schema (e.g., POST /api/tasks/complexity => { score:number, breakdown:{…} }).\n• Add input validation (task IDs, project scope).\n• Return HTTP 202 with polling or HTTP 200 depending on expected latency (<1 s vs >1 s).\n• Write unit tests for edge cases (no tasks, circular dependencies, large task sets).",
            "status": "done",
            "testStrategy": "Mock a variety of task lists and assert correct status codes and JSON schema using automated tests (Jest, pytest, etc.)."
          },
          {
            "id": 2,
            "title": "Add 'Analyze Complexity' button to task management UI",
            "description": "Insert a new button adjacent to the existing 'Add Task' button in the toolbar/header of the task management view.",
            "dependencies": [
              1
            ],
            "details": "• Update the UI component (e.g., Toolbar.jsx / TaskHeader.vue) to include a <Button>Analyze Complexity</Button> element.\n• Apply consistent styling, iconography, and tooltips per design system.\n• Ensure button is disabled when there are no tasks or while an analysis request is in flight.",
            "status": "done",
            "testStrategy": "Render component in Storybook; verify visual placement and disabled state toggling with unit tests."
          },
          {
            "id": 3,
            "title": "Implement click handler and API integration",
            "description": "Wire the new button’s onClick event to call the analyze-complexity endpoint and handle asynchronous states.",
            "dependencies": [
              2
            ],
            "details": "• Create useAnalyzeComplexity hook/service that sends the API request (axios/fetch) and returns {loading, data, error}.\n• Show a spinner or progress bar while loading.\n• Gracefully handle API errors (e.g., toast notification with retry option).\n• Cache recent results to avoid duplicate calls within same session if tasks unchanged.",
            "status": "done",
            "testStrategy": "Mock API with success & failure responses; assert UI state transitions using integration tests (React Testing Library/Vue Test Utils)."
          },
          {
            "id": 4,
            "title": "Design and integrate complexity results display",
            "description": "Create a modal or dedicated pane that presents the complexity score and detailed breakdown returned by the API.",
            "dependencies": [
              3
            ],
            "details": "• Build ComplexityReport component: header (overall score), table/chart for breakdown (dependencies count, estimated hours, resources).\n• Highlight high-risk metrics with color coding.\n• Allow users to close, re-run analysis, or export report (PDF/CSV placeholder).\n• Ensure accessibility (focus trapping, ARIA labels) and responsive design.",
            "status": "done",
            "testStrategy": "Visual regression tests with multiple data sets; Lighthouse accessibility audit."
          },
          {
            "id": 5,
            "title": "Performance, UX polish, and regression testing",
            "description": "Optimize API execution time, finalize UI/UX details, and ensure new features do not break existing functionality.",
            "dependencies": [
              4
            ],
            "details": "• Profile backend function; add indexing or in-memory caching if average response >1 s.\n• Lazy-load heavy chart libraries.\n• Conduct cross-browser testing and verify mobile responsiveness.\n• Update end-to-end tests (Cypress/Playwright) covering add task + analyze flow.\n• Update documentation and release notes.",
            "status": "done",
            "testStrategy": "Run load tests with various task volumes; execute full regression test suite in CI and compare baseline performance metrics."
          }
        ]
      },
      {
        "id": 15,
        "title": "Implement CLI Integration Tests",
        "description": "Develop integration tests for the Task Master CLI to automate testing without manual packaging.",
        "details": "To implement CLI integration tests, create a test suite using a testing framework like Mocha or Jest. These tests should execute the Task Master CLI commands, such as 'task-master list --with-subtasks --json', using Node.js's ChildProcess module. Capture and parse the CLI output to verify that the commands produce the expected results. Ensure that the tests cover various scenarios, including edge cases and error handling. Mock any external dependencies to isolate the CLI's functionality during testing. Additionally, set up a continuous integration pipeline to run these tests automatically on each commit.",
        "testStrategy": "1. Set up a testing environment with Mocha or Jest.\n2. Write test cases to execute CLI commands and capture their output.\n3. Verify that the output matches expected results for various scenarios, including normal operations and edge cases.\n4. Mock external dependencies to ensure tests focus on CLI functionality.\n5. Integrate the test suite into a CI pipeline to ensure tests run automatically on each commit.",
        "status": "done",
        "dependencies": [
          2
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 16,
        "title": "Prompt User for Research Option in Analyze Complexity",
        "description": "Enhance the analyze-complexity function to prompt users for research options before execution.",
        "details": "To implement this feature, modify the analyze-complexity function to include a user prompt that asks whether they want to conduct additional research related to the complexity analysis. This prompt should appear immediately after the user initiates the analyze-complexity function via the interface. If the user opts for research, provide options or links to relevant resources or tools that can assist in understanding or mitigating task complexity. Ensure the prompt is non-intrusive and integrates smoothly with the existing UI. Consider using a modal dialog or a notification banner for the prompt. Update the function logic to handle user responses appropriately, proceeding with the analysis if the user declines research.",
        "testStrategy": "1. Trigger the analyze-complexity function and verify that a prompt appears asking the user if they want to conduct research.\n2. Test the user interface to ensure the prompt is clear and provides actionable options for research.\n3. Validate that selecting 'Yes' for research provides appropriate resources or links.\n4. Ensure that selecting 'No' proceeds with the complexity analysis without interruption.\n5. Check that the prompt integrates seamlessly with the existing UI and does not disrupt the user experience.",
        "status": "done",
        "dependencies": [
          14
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Design User Prompt for Research Option",
            "description": "Create a user prompt that asks whether the user wants to conduct additional research related to the complexity analysis.",
            "dependencies": [],
            "details": "The prompt should be clear and concise, informing users about the option to access additional resources or tools to understand or mitigate task complexity. Ensure the language is user-friendly and aligns with the overall tone of the application.",
            "status": "done",
            "testStrategy": "Conduct usability testing to ensure the prompt is easily understood and effectively communicates the research option to users."
          },
          {
            "id": 2,
            "title": "Select Appropriate UI Component for Prompt Display",
            "description": "Choose a suitable UI component, such as a modal dialog or notification banner, to display the user prompt.",
            "dependencies": [
              1
            ],
            "details": "Evaluate the pros and cons of using modal dialogs versus notification banners. Modal dialogs are effective for capturing user attention but can be intrusive, while notification banners are less disruptive but may be overlooked. Consider the user experience and the importance of the prompt in the workflow.",
            "status": "done",
            "testStrategy": "A/B test different UI components to determine which one provides the best balance between visibility and user experience."
          },
          {
            "id": 3,
            "title": "Integrate User Prompt into analyze-complexity Function",
            "description": "Modify the analyze-complexity function to include the user prompt immediately after initiation.",
            "dependencies": [
              2
            ],
            "details": "Ensure that the prompt appears seamlessly after the user initiates the analyze-complexity function. The integration should not disrupt the existing workflow and should provide a smooth user experience.",
            "status": "done",
            "testStrategy": "Perform integration testing to verify that the prompt appears at the correct time and does not cause any disruptions or errors in the function's execution."
          },
          {
            "id": 4,
            "title": "Provide Relevant Research Resources Based on User Response",
            "description": "Offer options or links to relevant resources or tools if the user opts for additional research.",
            "dependencies": [
              3
            ],
            "details": "Curate a list of high-quality resources that can assist users in understanding or mitigating task complexity. Ensure that the resources are up-to-date and relevant to the user's needs.",
            "status": "done",
            "testStrategy": "Validate the relevance and accessibility of the provided resources through user feedback and regular reviews."
          },
          {
            "id": 5,
            "title": "Handle User Responses Appropriately",
            "description": "Update the function logic to proceed with the analysis if the user declines research, or to display resources if the user accepts.",
            "dependencies": [
              4
            ],
            "details": "Implement logic to handle both user responses: continue with the complexity analysis if the user declines additional research, or display the curated resources if the user accepts. Ensure that the transition between these states is smooth and intuitive.",
            "status": "done",
            "testStrategy": "Conduct end-to-end testing to ensure that the function behaves correctly based on different user responses and that the user experience remains consistent."
          }
        ]
      },
      {
        "id": 17,
        "title": "Enable Right-Click Menu on Subtasks",
        "description": "Implement a right-click context menu for subtasks in the task-management interface that lets users update details, change status, and remove a subtask. All persistence is handled locally through the task-master CLI data layer—there is no separate backend API.\n\nUPDATED STATUS (2024-06-11):\n• Right-click (contextmenu) interception on subtask elements is complete and merged (#17.1).\n• Custom context-menu UI with three actions (Update, Change Status, Remove) is fully implemented (#17.2).\n• Commands are registered in package.json and correctly wired to CLI services (#17.3).\n• Validation, error handling, and data persistence through TaskManagerService / TaskOperationsService confirmed via smoke tests.\n\nREMAINING WORK:\n1. Style & accessibility polish for the menu (high-contrast variables, focus ring, keyboard interaction edge cases).\n2. Robust cross-browser verification—including touch/long-press on supported devices—and formal accessibility validation (ARIA, screen-reader flows).\n3. Regression test pass to ensure no viewport-collision or dismissal issues.\n\nAll subsequent development must focus exclusively on UI/UX refinement, accessibility, and testing. Re-implementation of completed functionality is out of scope.",
        "status": "done",
        "dependencies": [
          13
        ],
        "priority": "medium",
        "details": "Implementation guidance for remaining tasks:\n\n• Styling: Ensure the .tm-context-menu follows design-system spacing (8-pt grid) and leverages CSS custom properties defined in theme-helpers.css. Provide explicit focus outline (2px solid var(--tm-focus-border)).\n• Accessibility: The menu element must keep role=\"menu\" with menuitem roles on children. Confirm ArrowUp/ArrowDown cycling, Home/End shortcuts, Enter/Space activation, and Esc dismissal with focus return.\n• Viewport collision: Current util.resizeToFit handles most cases—add unit tests for min-height scenarios and RTL layouts.\n• Browser matrix: Chrome ≥113, Firefox ≥111, Safari ≥16, Edge ≥113 on desktop; Chrome/Firefox on Android and Safari on iPadOS with external keyboard.\n• Error surfacing: The service layer already returns typed errors; surface them via toast notifications (toast.error) without console noise.\n• Touch: Verify long-press shows the same menu on touch devices (TreeView already sends contextmenu event after 500 ms long-press in VS Code 1.83+).\n\nNo additional business logic changes are required—focus on polish and compliance.",
        "testStrategy": "1. Visual & behavioral validation\n   a. Right-click on any subtask: custom menu appears, native menu suppressed.\n   b. Verify Update, Change Status, and Remove all function (already pass smoke tests).\n\n2. Accessibility\n   a. Navigate entire menu using keyboard—Tab to first item, Arrow keys cycle, Home/End jump, Enter/Space activates, Esc closes and restores focus.\n   b. Screen-reader (NVDA, VoiceOver, JAWS) announces menu role and each item label.\n\n3. Styling & theming\n   a. High-contrast themes: check contrast ≥4.5:1 for text and focus indicators.\n   b. Verify focus ring visibility on Windows High Contrast and macOS Increase Contrast.\n\n4. Viewport & positioning\n   a. Open menu near all four viewport edges and corners—menu must reposition to stay fully visible.\n   b. Test <400 px height window and RTL layout.\n\n5. Cross-browser & device matrix\n   a. Desktop: Chrome, Firefox, Safari, Edge (latest two major versions).\n   b. Touch: Chrome on Android 14 tablet, Safari on iPadOS 17; confirm long-press opens menu.\n\n6. Regression\n   a. Rapid open/close cycles (double-right-click) should not leave orphaned DOM nodes.\n   b. Ensure no console errors or unhandled promise rejections during all scenarios.",
        "subtasks": [
          {
            "id": 1,
            "title": "Intercept right-click events on subtask elements",
            "status": "done"
          },
          {
            "id": 2,
            "title": "Build custom context menu with Update, Change Status, and Remove actions",
            "status": "done",
            "details": "<info added on 2025-06-19T15:16:38.288Z>\nGoal\nCreate a clear, user-friendly context menu that appears when the user right-clicks a subtask.\n\nAcceptance Criteria\n• Context menu pops up at the cursor position on right-click.  \n• Options shown:  \n  – Rename / Edit  \n  – Change Status ▸ (Todo, In-Progress, Done)  \n  – Delete  \n• Menu closes when the user clicks elsewhere, presses Esc, or selects an option.  \n• Keyboard support: arrow keys to navigate, Enter to confirm, Esc to cancel.  \n• Use semantic HTML (ul/li) with role=\"menu\"/role=\"menuitem\" plus ARIA-labels for accessibility.  \n• Style matches existing dark theme; z-index keeps menu above other elements.  \n• No page scroll jump or text selection should occur when the menu opens.\n\nImplementation Notes\n1. Add ContextMenu.tsx component that receives (x, y, subtaskId) props.  \n2. Mount the component via a Portal to body to avoid clipping in nested containers.  \n3. Persist menu state in UI store (Redux/Context) so only one menu can be open.  \n4. Clean up event listeners on unmount to prevent memory leaks.  \n5. Provide unit tests for open/close logic and keyboard navigation.\n</info added on 2025-06-19T15:16:38.288Z>"
          },
          {
            "id": 3,
            "title": "Wire menu actions to task-master CLI (update, status change, delete)",
            "status": "done"
          },
          {
            "id": 4,
            "title": "Style menu and ensure accessibility compliance",
            "status": "done"
          }
        ]
      },
      {
        "id": 18,
        "title": "Add Fix Subtasks Action to Task Menu",
        "description": "Implement an action in the task menu to fix subtask IDs by converting them from a string format with parent ID to a simple numeric ID.",
        "details": "To implement the 'Fix Subtasks' action in the task menu, first update the task menu interface to include a new option labeled 'Fix Subtasks'. This option should be available when a task with subtasks is selected. Upon selection, the system should iterate through the subtasks of the selected task, identify any subtasks with IDs in the format 'parentID.subtaskID', and convert these to a simple numeric format by removing the parent ID prefix. Ensure that the changes are persisted correctly in the task management system and that the task rendering logic is updated to reflect these changes immediately. Consider edge cases such as duplicate subtask IDs after conversion and handle them appropriately.",
        "testStrategy": "1. Verify that the 'Fix Subtasks' option appears in the task menu when a task with subtasks is selected.\n2. Test the functionality by selecting the option and ensuring that subtask IDs are converted from 'parentID.subtaskID' to a simple numeric format.\n3. Validate that the changes are saved correctly and reflected in the task view immediately.\n4. Check for edge cases such as duplicate subtask IDs after conversion and ensure they are handled correctly.",
        "status": "done",
        "dependencies": [
          13,
          17
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 19,
        "title": "Enforce Minimum CLI Version Requirement",
        "description": "Prevent the extension from running if the Task Master AI CLI version is below 17.",
        "details": "To implement this feature, modify the initialization routine of the extension to include a version check for the Task Master AI CLI. Use the CLI's version command to retrieve the current version number. Compare this version against the minimum required version (17). If the current version is below 17, display an error message to the user and prevent further execution of the extension. Ensure that the error message is clear and provides instructions on how to update the CLI to the required version. Consider edge cases such as the CLI not being installed or the version command failing, and handle these scenarios gracefully by providing appropriate feedback to the user.",
        "testStrategy": "1. Simulate environments with different CLI versions and verify that the extension runs only when the version is 17 or higher.\n2. Test the error message display when the CLI version is below 17, ensuring it is clear and informative.\n3. Verify that the extension does not execute any further operations when the version check fails.\n4. Test scenarios where the CLI is not installed or the version command fails, ensuring appropriate error handling and user feedback.",
        "status": "done",
        "dependencies": [
          15
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement CLI Version Check in Extension Initialization",
            "description": "Modify the extension's initialization routine to include a check for the Task Master AI CLI version.",
            "dependencies": [],
            "details": "Update the extension's startup sequence to execute a version check command for the Task Master AI CLI. Ensure that the command retrieves the current CLI version accurately.",
            "status": "done",
            "testStrategy": "Unit test the initialization routine to confirm that the version check command executes correctly and retrieves the expected version number."
          },
          {
            "id": 2,
            "title": "Compare Retrieved CLI Version Against Minimum Requirement",
            "description": "Develop logic to compare the retrieved CLI version with the minimum required version (17).",
            "dependencies": [
              1
            ],
            "details": "Implement a function that parses the retrieved CLI version and compares it to the minimum required version. If the current version is below 17, set a flag to prevent further execution of the extension.",
            "status": "done",
            "testStrategy": "Create test cases with various CLI versions to verify that the comparison logic correctly identifies versions below and above the minimum requirement."
          },
          {
            "id": 3,
            "title": "Handle Error Scenarios and Provide User Feedback",
            "description": "Ensure the extension handles scenarios where the CLI is not installed or the version command fails, and provide clear error messages to the user.",
            "dependencies": [
              2
            ],
            "details": "Implement error handling to catch cases where the CLI is missing or the version command fails. Display an error message informing the user of the issue and provide instructions on how to install or update the CLI to meet the minimum version requirement.\n<info added on 2025-06-19T17:20:27.316Z>\nIntegrated initialization guards and unified the command-registration logic so that each CLI command is registered only once. This eliminates the “taskMaster.selectTag already exists” conflict observed during version validation and prevents any future duplicate-registration errors.\n</info added on 2025-06-19T17:20:27.316Z>",
            "status": "done",
            "testStrategy": "Simulate scenarios where the CLI is absent or the version command fails, and verify that the extension displays appropriate error messages and prevents further execution."
          }
        ]
      },
      {
        "id": 20,
        "title": "Implement Right-Click Context Menu for .txt Files to Trigger parse-prd Command",
        "description": "Enable a right-click context-menu entry for .txt files directly inside the operating-system File Explorer (e.g., Windows Explorer, Finder, Nautilus) that executes the parse-prd command with specified options.",
        "status": "done",
        "dependencies": [
          17,
          19
        ],
        "priority": "high",
        "details": "This feature must register a shell / Finder / file-manager extension so that when a user right-clicks any .txt file in their native File Explorer, a menu item labelled “Generate tasks with parse-prd” (or similar) is shown. Selecting that entry must:\n1. Launch the existing parse-prd CLI with the absolute path of the selected file as its first argument.\n2. Accept an optional parameter for the number of tasks to generate (defaulting to 10 if not provided). The UI should prompt the user for this value (e.g., via a small dialog) before invoking the command, or read a default from user settings.\n3. Capture stdout/stderr, surface progress, completion state, and any error messages back to the user (either through a notification toast or a minimal results window).\n\nImplementation notes:\n• Windows: add the context menu by creating a registry entry or packaged COM shell extension.\n• macOS: use a Finder Sync or Quick Actions extension (if support added later).\n• Linux desktop managers: rely on .desktop files or Nautilus/Nemo scripts (future work).\n• All command invocations must be sanitised to avoid command-injection vulnerabilities; escape or quote file paths appropriately.\n\nSecurity: Validate that the selected file really has a .txt extension, that only one file path is passed, and that no additional user-provided arguments are forwarded unchecked.",
        "testStrategy": "1. In the (native) File Explorer, right-click a .txt file and verify a new context-menu item labelled correctly appears.\n2. Click the item and confirm that parse-prd runs with the selected file path. Use a debugger or log to capture the exact command string.\n3. Execute with and without specifying --num-tasks to verify the default (10) and custom values work.\n4. Confirm UI feedback: progress indicator, success message with results, and graceful error handling if parse-prd fails.\n5. Perform security testing: attempt paths with special characters, spaces, and crafted inputs to ensure no command-injection or privilege-escalation issues.\n6. Regression-test existing CLI behaviour to ensure no breaking changes were introduced.",
        "subtasks": [
          {
            "id": 1,
            "title": "Research Methods to Add Context Menu Items for .txt Files",
            "description": "Investigate various approaches to add a right-click context menu option specifically for .txt files in Windows File Explorer.",
            "dependencies": [],
            "details": "Explore methods such as modifying the Windows Registry or using package extensions in the application manifest to add context menu items for .txt files.\n<info added on 2025-06-20T12:20:20.385Z>\nAfter investigation, confirmed that context-menu integration should target the VS Code Explorer, not the native OS shell. Use the “explorer/context” contribution point in package.json to add a right-click command for .txt files, ensuring the command appears only within VS Code’s file explorer and aligns with existing Task Master workflows.\n</info added on 2025-06-20T12:20:20.385Z>",
            "status": "done",
            "testStrategy": "Verify the feasibility and security implications of each method through documentation review and small-scale testing."
          },
          {
            "id": 2,
            "title": "Implement Context Menu Option for .txt Files",
            "description": "Add a right-click context menu option to .txt files that triggers the parse-prd command.",
            "dependencies": [
              1
            ],
            "details": "Based on the chosen method from the research, implement the context menu option that, when selected, executes the parse-prd command with the selected .txt file as input.",
            "status": "done",
            "testStrategy": "Test the context menu option to ensure it appears correctly and triggers the parse-prd command with the correct file path."
          },
          {
            "id": 3,
            "title": "Modify parse-prd Command to Accept Optional Parameter for Number of Tasks",
            "description": "Update the parse-prd command to accept an optional parameter specifying the number of tasks to generate, defaulting to 10 if not specified.",
            "dependencies": [],
            "details": "Enhance the parse-prd command-line interface to include an optional --num-tasks parameter, allowing users to specify the number of tasks to generate.",
            "status": "done",
            "testStrategy": "Test the parse-prd command with and without the --num-tasks parameter to ensure it generates the correct number of tasks."
          },
          {
            "id": 4,
            "title": "Integrate parse-prd Command Execution with Existing CLI",
            "description": "Ensure the parse-prd command is executed through the existing command-line interface, handling any output or errors appropriately.",
            "dependencies": [
              2,
              3
            ],
            "details": "Utilize the existing CLI integration to execute the parse-prd command when the context menu option is selected, capturing and displaying any output or errors.",
            "status": "done",
            "testStrategy": "Test the integration by selecting the context menu option and verifying that the parse-prd command executes correctly, with output and errors handled as expected."
          },
          {
            "id": 5,
            "title": "Update UI to Reflect Command Execution Status and Results",
            "description": "Modify the user interface to display the status and results of the parse-prd command execution initiated from the context menu.",
            "dependencies": [
              4
            ],
            "details": "Implement UI elements that provide feedback to the user regarding the execution status and results of the parse-prd command, such as progress indicators and result summaries.",
            "status": "done",
            "testStrategy": "Test the UI updates by executing the parse-prd command through the context menu and verifying that the status and results are displayed correctly."
          }
        ]
      },
      {
        "id": 21,
        "title": "Implement Workspace Detection Service",
        "description": "Create a comprehensive workspace detection service that can identify single-folder vs multi-root workspaces and monitor dynamic changes",
        "details": "Create WorkspaceDetectionService class with methods to detect workspace type, monitor changes via vscode.workspace.onDidChangeWorkspaceFolders, and provide workspace context. Implement WorkspaceContext interface with type detection ('single-folder' | 'multi-root' | 'empty'), folder enumeration, and .code-workspace file detection. Use VS Code API 1.74+ features for workspace folder management. Handle edge cases like empty workspaces and virtual file systems. Implement real-time updates when folders are added/removed. Use TypeScript 5.0+ with strict mode for type safety.",
        "testStrategy": "Unit tests for workspace type detection logic, integration tests for dynamic folder changes, mock VS Code workspace API for isolated testing, test edge cases with empty and virtual workspaces",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design WorkspaceContext Interface",
            "description": "Define the WorkspaceContext interface to encapsulate workspace type detection ('single-folder', 'multi-root', 'empty'), folder enumeration, and .code-workspace file detection.",
            "dependencies": [],
            "details": "Specify TypeScript types and structure for the WorkspaceContext interface, ensuring it supports all required properties and methods for workspace identification and context provision.",
            "status": "pending",
            "testStrategy": "Write TypeScript unit tests to validate type detection logic and ensure correct interface structure."
          },
          {
            "id": 2,
            "title": "Implement WorkspaceDetectionService Core Logic",
            "description": "Develop the WorkspaceDetectionService class with methods to detect workspace type, enumerate folders, and identify .code-workspace files using VS Code API 1.74+.",
            "dependencies": [
              1
            ],
            "details": "Implement detection logic for single-folder, multi-root, and empty workspaces, leveraging VS Code's workspace API and handling virtual file systems.",
            "status": "pending",
            "testStrategy": "Create unit tests to verify correct detection of workspace types and folder enumeration in various scenarios."
          },
          {
            "id": 3,
            "title": "Integrate Real-Time Workspace Monitoring",
            "description": "Add real-time monitoring to WorkspaceDetectionService using vscode.workspace.onDidChangeWorkspaceFolders to detect and respond to dynamic changes.",
            "dependencies": [
              2
            ],
            "details": "Ensure the service updates workspace context and emits events when folders are added or removed, supporting live updates.",
            "status": "pending",
            "testStrategy": "Simulate folder add/remove events and assert that the service updates context and notifies listeners appropriately."
          },
          {
            "id": 4,
            "title": "Handle Edge Cases and Virtual File Systems",
            "description": "Enhance detection logic to robustly handle edge cases such as empty workspaces and workspaces using virtual file systems.",
            "dependencies": [
              3
            ],
            "details": "Test and refine logic for scenarios where no folders are present or when folders are provided by non-standard file system providers.",
            "status": "pending",
            "testStrategy": "Write integration tests covering empty workspaces and virtual file system scenarios to ensure correct behavior."
          },
          {
            "id": 5,
            "title": "Ensure Type Safety and Strict Mode Compliance",
            "description": "Refactor and validate all code to comply with TypeScript 5.0+ strict mode, ensuring type safety throughout the WorkspaceDetectionService implementation.",
            "dependencies": [
              4
            ],
            "details": "Enable strict mode in tsconfig, resolve type errors, and enforce type-safe patterns across all interfaces and classes.",
            "status": "pending",
            "testStrategy": "Run TypeScript compiler with strict mode enabled and add type-focused tests to catch regressions."
          }
        ]
      },
      {
        "id": 22,
        "title": "Implement Configuration Hierarchy Service",
        "description": "Build a configuration resolution system with proper precedence handling for workspace-level, repository-level, and default configurations",
        "details": "Create ConfigurationResolver class implementing hierarchical config resolution: workspace-level (.code-workspace directory) > repository-level (individual .taskmaster directories) > extension defaults. Use vscode.workspace.getConfiguration() for workspace settings and fs.readFileSync for .taskmaster config files. Implement JSON schema validation using ajv@8.12.0 for config validation. Add file watchers using vscode.workspace.createFileSystemWatcher for dynamic config updates. Support both JSON and YAML config formats using js-yaml@4.1.0. Implement config merging with lodash.merge@4.6.2 for deep object merging.",
        "testStrategy": "Unit tests for config precedence rules, integration tests for file watching, test config validation with invalid JSON/YAML, verify dynamic config reloading",
        "priority": "high",
        "dependencies": [
          21
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design Configuration Hierarchy and Precedence Logic",
            "description": "Define the rules and structure for resolving configuration values from workspace-level, repository-level, and default sources, ensuring correct precedence and merging behavior.",
            "dependencies": [],
            "details": "Specify how the ConfigurationResolver will prioritize settings: workspace-level (.code-workspace directory) overrides repository-level (.taskmaster directories), which in turn override extension defaults. Document the expected merging and override rules.",
            "status": "pending",
            "testStrategy": "Create test cases with overlapping settings in different levels and verify the resolved configuration matches the defined precedence."
          },
          {
            "id": 2,
            "title": "Implement Configuration File Loading and Parsing",
            "description": "Develop logic to load and parse configuration files from the workspace and repository levels, supporting both JSON and YAML formats.",
            "dependencies": [
              1
            ],
            "details": "Use fs.readFileSync to read .taskmaster config files and js-yaml@4.1.0 to parse YAML files. Ensure robust error handling for invalid or missing files.",
            "status": "pending",
            "testStrategy": "Test with valid and invalid JSON/YAML files, and confirm correct parsing and error reporting."
          },
          {
            "id": 3,
            "title": "Integrate Workspace Settings Retrieval",
            "description": "Retrieve workspace-level configuration using vscode.workspace.getConfiguration() and integrate it into the resolution process.",
            "dependencies": [
              1
            ],
            "details": "Access VS Code workspace settings and ensure they are included in the configuration hierarchy with the highest precedence.",
            "status": "pending",
            "testStrategy": "Mock workspace settings and verify they override repository and default configurations as expected."
          },
          {
            "id": 4,
            "title": "Implement Configuration Validation and Merging",
            "description": "Validate loaded configurations against a JSON schema using ajv@8.12.0 and merge them using lodash.merge@4.6.2.",
            "dependencies": [
              2,
              3
            ],
            "details": "Apply schema validation to each configuration source before merging. Use lodash.merge for deep merging, ensuring correct override behavior.",
            "status": "pending",
            "testStrategy": "Provide sample configurations with schema violations and nested objects to test validation errors and merging correctness."
          },
          {
            "id": 5,
            "title": "Add Dynamic Configuration Updates with File Watchers",
            "description": "Implement file watchers using vscode.workspace.createFileSystemWatcher to detect and respond to configuration file changes in real time.",
            "dependencies": [
              4
            ],
            "details": "Set up watchers for both workspace and repository config files. On change, reload and re-validate configurations, and update the resolved configuration accordingly.",
            "status": "pending",
            "testStrategy": "Modify configuration files during runtime and verify that updates are detected, validated, merged, and applied without restarting the extension."
          }
        ]
      },
      {
        "id": 23,
        "title": "Refactor Task Tree Provider for Repository Grouping",
        "description": "Update TaskTreeProvider to support repository-level grouping in multi-root workspaces while maintaining backward compatibility",
        "details": "Extend TaskTreeProvider to create RepositoryTreeItem nodes for multi-root workspaces. Implement conditional rendering: repository nodes only appear in multi-root scenarios. Create TaskContext class to manage per-repository task state (current, next, all tasks). Use vscode.TreeItem with collapsibleState for repository nodes. Implement lazy loading for performance with many repositories. Add repository icons using VS Code's built-in codicons. Maintain tree state persistence using VS Code's memento API. Use Map<string, TaskContext> for efficient repository lookup. Implement tree refresh optimization to only update changed repositories.",
        "testStrategy": "Unit tests for tree structure generation, integration tests for single vs multi-root rendering, performance tests with 10+ repositories, test tree state persistence across VS Code restarts",
        "priority": "high",
        "dependencies": [
          21,
          22
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Extend TaskTreeProvider for Repository Nodes",
            "description": "Update TaskTreeProvider to create RepositoryTreeItem nodes for multi-root workspaces.",
            "dependencies": [],
            "details": "Implement conditional rendering to display repository nodes only in multi-root scenarios.",
            "status": "pending",
            "testStrategy": "Unit testing with mock data"
          },
          {
            "id": 2,
            "title": "Implement TaskContext Class",
            "description": "Create TaskContext class to manage per-repository task state.",
            "dependencies": [
              1
            ],
            "details": "Use TaskContext to track current, next, and all tasks per repository.",
            "status": "pending",
            "testStrategy": "Integration testing with real repository data"
          },
          {
            "id": 3,
            "title": "Implement Lazy Loading and Collapsible Repository Nodes",
            "description": "Use vscode.TreeItem with collapsibleState for repository nodes and implement lazy loading.",
            "dependencies": [
              2
            ],
            "details": "Optimize performance by loading repository nodes on demand.",
            "status": "pending",
            "testStrategy": "Performance testing with large repository sets"
          },
          {
            "id": 4,
            "title": "Add Repository Icons and Tree State Persistence",
            "description": "Add repository icons using VS Code's built-in codicons and maintain tree state persistence.",
            "dependencies": [
              3
            ],
            "details": "Use VS Code's memento API for tree state persistence.",
            "status": "pending",
            "testStrategy": "UI testing for icon display and state persistence"
          },
          {
            "id": 5,
            "title": "Implement Tree Refresh Optimization",
            "description": "Optimize tree refresh to only update changed repositories.",
            "dependencies": [
              4
            ],
            "details": "Use Map<string, TaskContext> for efficient repository lookup during refresh.",
            "status": "pending",
            "testStrategy": "Regression testing for backward compatibility"
          }
        ]
      },
      {
        "id": 24,
        "title": "Update Service Layer for Multi-Workspace Support",
        "description": "Refactor all existing services to eliminate deprecated API usage and support multiple workspace folders",
        "details": "Update TagService, CLIService, TaskCacheService, TaskOperationsService, ConfigService, and FileWatcherService to iterate through all workspace folders instead of using workspaceFolders[0]. Replace all instances of deprecated vscode.workspace.rootPath with vscode.workspace.workspaceFolders. Implement per-repository task file management using path.join(folder.uri.fsPath, '.taskmaster'). Add error handling for folders without .taskmaster directories. Use Promise.allSettled() for concurrent operations across repositories. Implement repository context passing through service method parameters. Add logging using VS Code's output channel for debugging multi-workspace operations.",
        "testStrategy": "Unit tests for each service with multiple workspace folders, integration tests for cross-service operations, test error handling for missing .taskmaster directories, verify no deprecated API usage with static analysis",
        "priority": "high",
        "dependencies": [
          21,
          22
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Refactor Services to Iterate Over All Workspace Folders",
            "description": "Update TagService, CLIService, TaskCacheService, TaskOperationsService, ConfigService, and FileWatcherService to iterate through all workspace folders instead of using workspaceFolders.",
            "dependencies": [],
            "details": "Replace all logic that assumes a single workspace folder with iteration over vscode.workspace.workspaceFolders, ensuring each service operates on every folder in the workspace.",
            "status": "pending",
            "testStrategy": "Verify that each service processes all workspace folders by running integration tests with multiple folders open and confirming correct behavior in each."
          },
          {
            "id": 2,
            "title": "Replace Deprecated API Usage",
            "description": "Replace all instances of vscode.workspace.rootPath with vscode.workspace.workspaceFolders and update related code to use the new API.",
            "dependencies": [
              1
            ],
            "details": "Search for all usages of the deprecated rootPath API and refactor them to use workspaceFolders, ensuring compatibility with the latest VS Code API.",
            "status": "pending",
            "testStrategy": "Run automated tests and manual checks to confirm that no deprecated API calls remain and that workspace folder detection works as expected."
          },
          {
            "id": 3,
            "title": "Implement Per-Repository Task File Management",
            "description": "Update services to manage task files per repository using path.join(folder.uri.fsPath, '.taskmaster') and add error handling for missing directories.",
            "dependencies": [
              2
            ],
            "details": "Ensure each workspace folder has its own .taskmaster directory, handle cases where the directory is missing, and provide appropriate error messages or fallback behavior.",
            "status": "pending",
            "testStrategy": "Test with workspaces containing and lacking .taskmaster directories, verifying correct error handling and file management in each scenario."
          },
          {
            "id": 4,
            "title": "Enable Concurrent Operations and Repository Context Passing",
            "description": "Refactor service methods to accept repository context parameters and use Promise.allSettled() for concurrent operations across repositories.",
            "dependencies": [
              3
            ],
            "details": "Modify method signatures to include repository context, and update internal logic to perform operations concurrently using Promise.allSettled() for efficiency and robustness.",
            "status": "pending",
            "testStrategy": "Write unit and integration tests to confirm that concurrent operations are handled correctly and that repository context is passed and utilized as intended."
          },
          {
            "id": 5,
            "title": "Add Logging for Multi-Workspace Operations",
            "description": "Implement logging using VS Code's output channel to aid debugging and monitoring of multi-workspace operations.",
            "dependencies": [
              4
            ],
            "details": "Integrate logging statements throughout the refactored services to capture key events, errors, and operation results, using the VS Code output channel.",
            "status": "pending",
            "testStrategy": "Manually review logs during multi-workspace operations to ensure relevant information is captured and errors are clearly reported."
          }
        ]
      },
      {
        "id": 25,
        "title": "Enhance Command System and File Watching",
        "description": "Update command system to work with repository context and implement comprehensive file watching across all workspace folders",
        "details": "Add new commands: taskMaster.selectRepository, taskMaster.refreshRepository, taskMaster.openRepositorySettings. Update existing commands to accept repository context parameter. Implement repository selection QuickPick UI for multi-root scenarios using vscode.window.showQuickPick. Create WorkspaceFileWatcher class managing Map<string, vscode.FileSystemWatcher> for per-folder watchers. Use glob patterns '**/.taskmaster/**' for efficient file watching. Implement watcher cleanup on folder removal and extension deactivation. Add command palette integration with repository names. Use vscode.commands.registerCommand with proper disposal tracking.",
        "testStrategy": "Unit tests for command registration and repository context handling, integration tests for file watcher management, test command execution in both single and multi-root scenarios, verify proper cleanup on extension deactivation",
        "priority": "medium",
        "dependencies": [
          21,
          22,
          23,
          24
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Add New Repository Commands",
            "description": "Implement the new commands: taskMaster.selectRepository, taskMaster.refreshRepository, and taskMaster.openRepositorySettings.",
            "dependencies": [],
            "details": "Define and register the new commands using vscode.commands.registerCommand. Ensure each command is properly integrated with the command palette and supports disposal tracking.",
            "status": "pending",
            "testStrategy": "Verify that each new command appears in the command palette and executes the intended functionality for different repository contexts."
          },
          {
            "id": 2,
            "title": "Update Existing Commands for Repository Context",
            "description": "Modify existing commands to accept and utilize a repository context parameter.",
            "dependencies": [
              1
            ],
            "details": "Refactor command handlers to accept a repository context argument. Ensure backward compatibility and update command registrations as needed.",
            "status": "pending",
            "testStrategy": "Test all updated commands with and without repository context to confirm correct behavior and no regressions."
          },
          {
            "id": 3,
            "title": "Implement Repository Selection QuickPick UI",
            "description": "Create a QuickPick UI for selecting repositories in multi-root workspace scenarios using vscode.window.showQuickPick.",
            "dependencies": [
              1
            ],
            "details": "Develop a UI component that lists available repositories and returns the user's selection. Integrate this UI with relevant commands requiring repository selection.",
            "status": "pending",
            "testStrategy": "Simulate multi-root workspaces and verify that the QuickPick UI displays all repositories and returns the correct selection."
          },
          {
            "id": 4,
            "title": "Develop WorkspaceFileWatcher Class for Per-Folder Watching",
            "description": "Create a WorkspaceFileWatcher class that manages a Map<string, vscode.FileSystemWatcher> for efficient per-folder file watching.",
            "dependencies": [
              2,
              3
            ],
            "details": "Implement file watching using glob patterns '**/.taskmaster/**' for each workspace folder. Ensure watchers are created, managed, and cleaned up appropriately.",
            "status": "pending",
            "testStrategy": "Add, modify, and remove files in .taskmaster folders across multiple workspace folders and verify watcher events are triggered and cleaned up as expected."
          },
          {
            "id": 5,
            "title": "Integrate Watcher Cleanup and Command Palette Enhancements",
            "description": "Implement watcher cleanup on folder removal and extension deactivation. Enhance command palette integration to display repository names.",
            "dependencies": [
              4
            ],
            "details": "Ensure all file watchers are disposed of when folders are removed or the extension is deactivated. Update command palette entries to include repository names for clarity.",
            "status": "pending",
            "testStrategy": "Remove workspace folders and deactivate the extension to confirm watcher cleanup. Check command palette for correct repository name display."
          }
        ]
      },
      {
        "id": 26,
        "title": "Implement Core Subtask Creation Commands",
        "description": "Implement the add-subtask command functionality including manual subtask creation and task-to-subtask conversion with comprehensive input validation and UI workflows.",
        "details": "Create new file `src/commands/subtaskCommands.ts` with command handlers. Implement `addSubtask()` and `convertTaskToSubtask()` methods in `TaskOperationsService`. Add multi-step input workflow using `vscode.window.showInputBox()` and `vscode.window.showQuickPick()` for title, description, and dependency selection. Integrate with CLI service using `add-subtask` and `add-subtask --task-id` commands. Update `package.json` with new command definitions: `taskMaster.addSubtask` and `taskMaster.addSubtaskFromTask`. Add context menu items to task nodes in tree view. Implement input validation to ensure parent task exists and is not itself a subtask. Use VS Code's built-in progress indicators for long-running operations. Follow existing error handling patterns with `vscode.window.showErrorMessage()` for user feedback.",
        "testStrategy": "Unit tests for command handlers with mocked CLI responses. Integration tests for complete workflow from command invocation to tree view refresh. Test input validation edge cases including invalid parent tasks, circular dependencies, and empty inputs. Manual testing of multi-step input flows and context menu integration.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define and Register Subtask Commands in VS Code",
            "description": "Create new command definitions for 'add-subtask' and 'add-subtask --task-id' in package.json and register their handlers in src/commands/subtaskCommands.ts using VS Code's command API.",
            "dependencies": [],
            "details": "Ensure commands are properly registered and appear in the command palette and context menus. Use vscode.commands.registerCommand and update contributes.commands in package.json.",
            "status": "pending",
            "testStrategy": "Verify commands appear in the command palette and context menus, and that handlers are invoked when triggered."
          },
          {
            "id": 2,
            "title": "Implement addSubtask and convertTaskToSubtask Methods",
            "description": "Develop addSubtask() and convertTaskToSubtask() methods in TaskOperationsService to handle manual subtask creation and task-to-subtask conversion logic.",
            "dependencies": [
              1
            ],
            "details": "Ensure methods support all required input parameters, handle task relationships, and update the data model accordingly.",
            "status": "pending",
            "testStrategy": "Unit test both methods for correct subtask creation, conversion, and error handling."
          },
          {
            "id": 3,
            "title": "Design Multi-Step Input Workflow for Subtask Creation",
            "description": "Implement a multi-step input process using vscode.window.showInputBox and showQuickPick for collecting subtask title, description, and dependencies.",
            "dependencies": [
              2
            ],
            "details": "Guide users through each input step, validate entries, and allow cancellation at any stage.",
            "status": "pending",
            "testStrategy": "Test the workflow for correct input collection, validation, and user experience, including edge cases and cancellations."
          },
          {
            "id": 4,
            "title": "Integrate CLI and UI Workflows with Input Validation and Progress Indicators",
            "description": "Connect the command handlers to both CLI and UI workflows, ensuring comprehensive input validation, parent task checks, and use of VS Code's progress indicators for long-running operations.",
            "dependencies": [
              3
            ],
            "details": "Validate that parent tasks exist and are not themselves subtasks. Use vscode.window.withProgress for feedback during operations.",
            "status": "pending",
            "testStrategy": "Test CLI and UI flows for correct validation, error handling, and progress display."
          },
          {
            "id": 5,
            "title": "Implement Error Handling and User Feedback Mechanisms",
            "description": "Follow existing error handling patterns using vscode.window.showErrorMessage for user feedback and ensure all failure scenarios are gracefully managed.",
            "dependencies": [
              4
            ],
            "details": "Handle all possible errors, such as invalid input, missing parent tasks, or failed operations, and provide clear messages to the user.",
            "status": "pending",
            "testStrategy": "Simulate error scenarios and verify that appropriate error messages are shown and the extension remains stable."
          }
        ]
      },
      {
        "id": 27,
        "title": "Implement Subtask Removal and Conversion Features",
        "description": "Extend existing subtask removal functionality to support conversion to standalone tasks and implement clear all subtasks functionality with bulk operations support.",
        "details": "Enhance existing `removeSubtask()` method in `TaskOperationsService` to support `--convert` flag. Create `clearSubtasks()` method for bulk subtask removal. Modify subtask context menu to show options: 'Delete Subtask' and 'Convert to Standalone Task'. Implement confirmation dialogs using `vscode.window.showWarningMessage()` with custom buttons. Add 'Clear All Subtasks' command with subtask count display in confirmation. Support multi-select operations for bulk clearing. Integrate with CLI commands `remove-subtask --convert` and `clear-subtasks`. Update command registration in `package.json` for `taskMaster.convertSubtaskToTask` and `taskMaster.clearSubtasks`. Preserve subtask data during conversion including dependencies and metadata. Handle dependency relationship updates when converting subtasks to tasks.",
        "testStrategy": "Test both deletion and conversion modes of subtask removal. Verify data preservation during conversion operations. Test bulk clear operations with various subtask counts. Validate confirmation dialogs and user choice handling. Test dependency relationship updates during conversions.",
        "priority": "high",
        "dependencies": [
          26
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Enhance removeSubtask() to Support Conversion",
            "description": "Update the existing removeSubtask() method in TaskOperationsService to support a --convert flag, enabling conversion of a subtask into a standalone task while preserving dependencies and metadata.",
            "dependencies": [],
            "details": "Implement logic to handle the --convert flag, ensuring all subtask data, dependencies, and metadata are retained and correctly updated during conversion.",
            "status": "pending",
            "testStrategy": "Unit test removeSubtask() with and without the --convert flag, verifying correct conversion and data preservation."
          },
          {
            "id": 2,
            "title": "Implement clearSubtasks() for Bulk Removal",
            "description": "Create a clearSubtasks() method in TaskOperationsService to support bulk removal of all subtasks, including multi-select operations.",
            "dependencies": [],
            "details": "Design the method to efficiently remove multiple subtasks at once, supporting both single and multi-select scenarios.",
            "status": "pending",
            "testStrategy": "Test clearSubtasks() with varying numbers of subtasks, ensuring all are removed as expected and edge cases are handled."
          },
          {
            "id": 3,
            "title": "Update Subtask Context Menu and Confirmation Dialogs",
            "description": "Modify the subtask context menu to include 'Delete Subtask' and 'Convert to Standalone Task' options, and implement confirmation dialogs using vscode.window.showWarningMessage() with custom buttons.",
            "dependencies": [
              1
            ],
            "details": "Ensure the context menu reflects new options and that confirmation dialogs display appropriate messages and buttons for each action.",
            "status": "pending",
            "testStrategy": "Verify menu options appear correctly and dialogs function as intended, including correct button actions."
          },
          {
            "id": 4,
            "title": "Add 'Clear All Subtasks' Command with Count Display",
            "description": "Implement a 'Clear All Subtasks' command that displays the number of subtasks to be removed in the confirmation dialog and supports CLI integration.",
            "dependencies": [
              2,
              3
            ],
            "details": "Integrate with CLI commands remove-subtask --convert and clear-subtasks, and update package.json for command registration.",
            "status": "pending",
            "testStrategy": "Test the command in both UI and CLI, confirming correct subtask count display and successful bulk removal."
          },
          {
            "id": 5,
            "title": "Handle Dependency Updates and Data Integrity",
            "description": "Ensure that when converting subtasks to standalone tasks, all dependency relationships and metadata are updated to maintain data integrity.",
            "dependencies": [
              1,
              4
            ],
            "details": "Implement logic to update dependencies and verify that no orphaned or broken links remain after conversion or removal.",
            "status": "pending",
            "testStrategy": "Test conversion and removal scenarios, checking that dependencies and metadata are correctly updated and no data is lost."
          }
        ]
      },
      {
        "id": 28,
        "title": "Implement Subtask Movement and Reorganization",
        "description": "Add subtask movement capabilities including moving between parent tasks, reordering within same parent, and converting to standalone tasks with validation to prevent circular dependencies.",
        "details": "Implement `moveSubtask()` method in `TaskOperationsService` with support for different move scenarios. Create destination selection dialog using `vscode.window.showQuickPick()` with task list and 'Convert to Standalone Task' option. Add 'Move Subtask' to subtask context menu. Integrate with CLI `move` command with appropriate parameters. Implement circular dependency validation before allowing moves. Create preview functionality showing new position before confirming move. Add command registration for `taskMaster.moveSubtask`. Support moving subtasks between different parent tasks while preserving subtask properties. Handle reordering within same parent using position parameters. Update tree view provider to reflect changes immediately after move operations.",
        "testStrategy": "Test moving subtasks between different parent tasks. Verify reordering within same parent works correctly. Test conversion to standalone task during move. Validate circular dependency prevention. Test preview functionality and user confirmation flows.",
        "priority": "medium",
        "dependencies": [
          27
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement moveSubtask() Method with Move Scenarios",
            "description": "Develop the moveSubtask() method in TaskOperationsService to support moving subtasks between parent tasks, reordering within the same parent, and converting subtasks to standalone tasks.",
            "dependencies": [],
            "details": "Ensure the method handles all move scenarios, preserves subtask properties, and supports position parameters for reordering.",
            "status": "pending",
            "testStrategy": "Unit test moveSubtask() for each scenario, verifying correct parent assignment, order, and standalone conversion."
          },
          {
            "id": 2,
            "title": "Create Destination Selection Dialog and Preview Functionality",
            "description": "Design and implement a dialog using vscode.window.showQuickPick() to select the destination for moving a subtask, including a 'Convert to Standalone Task' option, and provide a preview of the new position before confirmation.",
            "dependencies": [
              1
            ],
            "details": "The dialog should list available tasks and allow users to preview the subtask's new location before finalizing the move.",
            "status": "pending",
            "testStrategy": "Test dialog usability, correct listing of tasks, and accurate preview rendering for all move types."
          },
          {
            "id": 3,
            "title": "Integrate Move Subtask Feature with UI and CLI",
            "description": "Add 'Move Subtask' to the subtask context menu and integrate the move functionality with the CLI 'move' command, ensuring appropriate parameters are supported.",
            "dependencies": [
              2
            ],
            "details": "Ensure both UI and CLI trigger the same move logic and support all move scenarios.",
            "status": "pending",
            "testStrategy": "Test context menu and CLI command for correct invocation and parameter handling."
          },
          {
            "id": 4,
            "title": "Implement Circular Dependency Validation",
            "description": "Develop validation logic to prevent circular dependencies before allowing subtask moves.",
            "dependencies": [
              1
            ],
            "details": "Ensure that moving a subtask does not create a cycle in the task hierarchy.",
            "status": "pending",
            "testStrategy": "Test with various move attempts that would and would not create cycles, confirming correct validation behavior."
          },
          {
            "id": 5,
            "title": "Update Tree View Provider and Command Registration",
            "description": "Update the tree view provider to reflect subtask moves immediately and register the 'taskMaster.moveSubtask' command.",
            "dependencies": [
              3,
              4
            ],
            "details": "Ensure the UI updates in real time after move operations and that the command is properly registered and accessible.",
            "status": "pending",
            "testStrategy": "Test tree view updates after moves and verify command registration and execution."
          }
        ]
      },
      {
        "id": 29,
        "title": "Implement Subtask Dependency Management",
        "description": "Add comprehensive dependency management for subtasks including adding/removing dependencies with validation and enhanced display of dependency information in the tree view.",
        "details": "Extend existing dependency management to support subtasks. Create `addSubtaskDependency()` and `removeSubtaskDependency()` methods in `TaskOperationsService`. Add 'Manage Dependencies' submenu to subtask context menu with 'Add Dependency' and 'Remove Dependency' options. Implement dependency selection dialogs using `vscode.window.showQuickPick()` with multi-select support. Update `TaskTreeProvider` to display dependency indicators for subtasks using VS Code icons (e.g., `$(link)`). Enhance subtask tooltips to include dependency information. Integrate with CLI dependency commands for subtasks. Implement circular dependency validation to prevent invalid dependency chains. Add command registrations for `taskMaster.addSubtaskDependency` and `taskMaster.removeSubtaskDependency`. Update tree item context values to show dependency management options only when applicable.",
        "testStrategy": "Test adding and removing dependencies for subtasks. Verify circular dependency validation prevents invalid operations. Test dependency display in tree view and tooltips. Validate multi-select dependency selection dialogs. Test integration with CLI dependency commands.",
        "priority": "medium",
        "dependencies": [
          28
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Subtask Dependency Methods in TaskOperationsService",
            "description": "Create addSubtaskDependency() and removeSubtaskDependency() methods in TaskOperationsService to handle adding and removing dependencies for subtasks, including validation logic.",
            "dependencies": [],
            "details": "Extend the TaskOperationsService with robust methods for managing subtask dependencies. Ensure these methods validate input, prevent duplicates, and support integration with CLI commands.",
            "status": "pending",
            "testStrategy": "Unit test both methods for correct addition, removal, and validation of dependencies, including edge cases such as duplicate and invalid dependencies."
          },
          {
            "id": 2,
            "title": "Add 'Manage Dependencies' Submenu to Subtask Context Menu",
            "description": "Integrate a 'Manage Dependencies' submenu into the subtask context menu, providing 'Add Dependency' and 'Remove Dependency' options.",
            "dependencies": [
              1
            ],
            "details": "Update the context menu for subtasks in the UI to include dependency management options, ensuring these options are only visible when applicable based on subtask state.",
            "status": "pending",
            "testStrategy": "Verify submenu visibility and correct triggering of dependency management commands through UI tests."
          },
          {
            "id": 3,
            "title": "Implement Dependency Selection Dialogs with Multi-Select Support",
            "description": "Develop dialogs using vscode.window.showQuickPick() for selecting dependencies to add or remove, supporting multi-select and integrating with the new subtask dependency methods.",
            "dependencies": [
              2
            ],
            "details": "Ensure dialogs are user-friendly, prevent selection of invalid or circular dependencies, and pass selected items to the appropriate service methods.",
            "status": "pending",
            "testStrategy": "Test dialog behavior for various selection scenarios, including multi-select, invalid selections, and cancellation."
          },
          {
            "id": 4,
            "title": "Enhance TaskTreeProvider to Display Subtask Dependency Indicators",
            "description": "Update TaskTreeProvider to show dependency indicators (e.g., VS Code $(link) icon) for subtasks and enhance tooltips to include dependency information.",
            "dependencies": [
              3
            ],
            "details": "Modify the tree view rendering logic to visually indicate dependencies and provide detailed dependency info in tooltips for each subtask.",
            "status": "pending",
            "testStrategy": "UI test the tree view to confirm correct icons and tooltip content for subtasks with and without dependencies."
          },
          {
            "id": 5,
            "title": "Integrate Circular Dependency Validation and Command Registrations",
            "description": "Implement validation to prevent circular dependencies among subtasks and register taskMaster.addSubtaskDependency and taskMaster.removeSubtaskDependency commands.",
            "dependencies": [
              4
            ],
            "details": "Ensure that dependency chains are validated for cycles before changes are applied, and that all relevant commands are registered and functional in the extension.",
            "status": "pending",
            "testStrategy": "Test with various dependency graphs to confirm circular dependencies are blocked and commands are correctly registered and executed."
          }
        ]
      },
      {
        "id": 30,
        "title": "Integrate Command Palette and Enhance Error Handling",
        "description": "Complete the implementation by adding all subtask commands to VS Code command palette, implementing comprehensive error handling, and ensuring robust validation across all subtask operations.",
        "details": "Add all new subtask commands to VS Code command palette with descriptive names and logical grouping. Implement intelligent context awareness for command availability using `when` clauses. Create global command handlers that provide task/subtask selection when invoked without context. Implement comprehensive input validation for all subtask operations using TypeScript type guards and custom validation functions. Add consistent error handling patterns using `try-catch` blocks and user-friendly error messages via `vscode.window.showErrorMessage()`. Create logging system for debugging subtask operations using VS Code's output channel. Add workspace trust validation for all subtask operations. Implement graceful CLI command failure handling with fallback options. Create utility functions in `src/utils/subtaskUtils.ts` for common validation and formatting tasks. Update all command registrations in `package.json` with proper titles, categories, and icons.",
        "testStrategy": "Test all commands through command palette with and without active selections. Verify error handling for various failure scenarios including CLI errors, invalid inputs, and workspace trust issues. Test logging functionality and error message clarity. Validate command availability based on context and workspace state.",
        "priority": "medium",
        "dependencies": [
          29
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Register All Subtask Commands in Command Palette",
            "description": "Add all new subtask commands to the VS Code command palette with descriptive names, logical grouping, and appropriate metadata in package.json.",
            "dependencies": [],
            "details": "Ensure each subtask command is registered in package.json with clear titles, categories, and icons. Use logical grouping for discoverability and follow VS Code's UX guidelines for command naming and organization.",
            "status": "pending",
            "testStrategy": "Verify that all commands appear in the Command Palette with correct names and grouping by searching for them using Ctrl+Shift+P."
          },
          {
            "id": 2,
            "title": "Implement Context Awareness and Global Command Handlers",
            "description": "Add intelligent context awareness for command availability using 'when' clauses and create global handlers that prompt for task/subtask selection when invoked without context.",
            "dependencies": [
              1
            ],
            "details": "Utilize 'when' clauses in package.json to control command visibility based on editor state. Implement global command handlers that display a quick pick menu for selecting tasks or subtasks if no context is provided.",
            "status": "pending",
            "testStrategy": "Test command visibility in various contexts and ensure global handlers prompt for selection when needed."
          },
          {
            "id": 3,
            "title": "Implement Comprehensive Input Validation",
            "description": "Add robust input validation for all subtask operations using TypeScript type guards and custom validation functions.",
            "dependencies": [
              2
            ],
            "details": "Create utility functions in src/utils/subtaskUtils.ts for common validation and formatting tasks. Ensure all user inputs and command arguments are validated before processing.",
            "status": "pending",
            "testStrategy": "Write unit tests for validation utilities and simulate invalid inputs to confirm proper error detection."
          },
          {
            "id": 4,
            "title": "Enhance Error Handling and User Feedback",
            "description": "Apply consistent error handling patterns using try-catch blocks and display user-friendly error messages via vscode.window.showErrorMessage().",
            "dependencies": [
              3
            ],
            "details": "Wrap all subtask operations in try-catch blocks. On error, show clear, actionable messages to the user and log technical details for debugging.",
            "status": "pending",
            "testStrategy": "Force errors in subtask operations and verify that user-facing messages are clear and logs are generated."
          },
          {
            "id": 5,
            "title": "Integrate Logging, Workspace Trust, and CLI Fallbacks",
            "description": "Create a logging system using VS Code's output channel, add workspace trust validation for all subtask operations, and implement graceful CLI command failure handling with fallback options.",
            "dependencies": [
              4
            ],
            "details": "Set up an output channel for logging subtask activity and errors. Check workspace trust before executing operations. For CLI failures, provide fallback options or informative messages.",
            "status": "pending",
            "testStrategy": "Test logging output, simulate untrusted workspace scenarios, and verify CLI fallback mechanisms."
          }
        ]
      },
      {
        "id": 31,
        "title": "Implement Core Interaction Manager and Notification Service",
        "description": "Create the foundational InteractionManager singleton and NotificationService to standardize all alert/notification patterns across the VSCode extension, replacing 98+ scattered instances of vscode.window.show*Message() calls.",
        "details": "Create the core interaction infrastructure:\n\n1. **InteractionManager.ts**: Implement singleton pattern with lazy initialization\n```typescript\nexport class InteractionManager {\n  private static instance: InteractionManager;\n  public readonly notify: NotificationService;\n  public readonly dialog: DialogService;\n  public readonly progress: ProgressService;\n  public readonly error: ErrorService;\n  public readonly workflow: WorkflowService;\n\n  private constructor() {\n    this.notify = new NotificationService();\n    // Initialize other services\n  }\n\n  public static getInstance(): InteractionManager {\n    if (!InteractionManager.instance) {\n      InteractionManager.instance = new InteractionManager();\n    }\n    return InteractionManager.instance;\n  }\n}\n```\n\n2. **NotificationService.ts**: Implement standardized notification patterns\n```typescript\nexport class NotificationService {\n  async success(message: string, actions?: NotificationAction[]): Promise<string | undefined> {\n    return vscode.window.showInformationMessage(message, ...actions?.map(a => a.title) || []);\n  }\n\n  async validationWarning(messageKey: string): Promise<void> {\n    const messages = {\n      'task_id_required': 'No task ID provided',\n      'subtask_selection_required': 'No subtask selected'\n    };\n    await vscode.window.showWarningMessage(messages[messageKey] || messageKey);\n  }\n\n  async taskSuccess(taskId: number, operation: string): Promise<void> {\n    await this.success(`Task ${taskId} ${operation} successfully`);\n  }\n}\n```\n\n3. **Type Definitions**: Create comprehensive TypeScript interfaces in types/ directory\n4. **Message Formatter**: Implement consistent message formatting with icon support\n5. **Migration Strategy**: Create backward-compatible wrapper functions\n\nUse VSCode Extension API 1.74+ for latest notification features. Implement proper error boundaries and fallback mechanisms.",
        "testStrategy": "Unit tests for InteractionManager singleton behavior, NotificationService message formatting, and type safety. Integration tests for VSCode API interaction patterns. Mock vscode.window methods for isolated testing. Test notification action handling and message categorization logic.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design and Implement InteractionManager Singleton",
            "description": "Create the InteractionManager class as a singleton with lazy initialization, ensuring it provides access to all core interaction services (NotificationService, DialogService, ProgressService, ErrorService, WorkflowService).",
            "dependencies": [],
            "details": "Implement the InteractionManager.ts file using the singleton pattern. Ensure that each service is initialized only once and is accessible via the singleton instance. Follow best practices for singleton implementation in TypeScript.",
            "status": "pending",
            "testStrategy": "Write unit tests to verify singleton behavior, service initialization, and correct instance retrieval."
          },
          {
            "id": 2,
            "title": "Develop NotificationService with Standardized Patterns",
            "description": "Implement NotificationService to provide consistent notification and alert patterns, replacing direct calls to vscode.window.show*Message().",
            "dependencies": [
              1
            ],
            "details": "Create NotificationService.ts with methods for success, warning, error, and validation messages. Ensure all messages follow a standardized format and leverage the latest VSCode Extension API features for notifications.",
            "status": "pending",
            "testStrategy": "Test each notification method for correct message display, action handling, and compatibility with VSCode API 1.74+."
          },
          {
            "id": 3,
            "title": "Define Comprehensive TypeScript Interfaces",
            "description": "Create and document all necessary TypeScript interfaces and types in the types/ directory to support interaction and notification services.",
            "dependencies": [
              1,
              2
            ],
            "details": "Define interfaces for notification actions, message payloads, dialog options, and other relevant types. Ensure type safety and extensibility for future interaction patterns.",
            "status": "pending",
            "testStrategy": "Validate type definitions through TypeScript compilation and by integrating them in service implementations."
          },
          {
            "id": 4,
            "title": "Implement Consistent Message Formatter with Icon Support",
            "description": "Develop a message formatting utility to ensure all notifications and dialogs have a consistent style, including support for icons and dynamic content.",
            "dependencies": [
              2,
              3
            ],
            "details": "Create a formatter module or class that can be used by NotificationService and other services to generate messages with icons, prefixes, and standardized layouts.",
            "status": "pending",
            "testStrategy": "Test message formatting with various message types and icons. Verify visual consistency in the VSCode UI."
          },
          {
            "id": 5,
            "title": "Develop Migration Strategy and Backward-Compatible Wrappers",
            "description": "Create wrapper functions and a migration plan to replace all existing vscode.window.show*Message() calls with the new InteractionManager and NotificationService.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Identify all current usages of show*Message() in the codebase. Implement wrappers that redirect calls to the new services, ensuring backward compatibility and minimal disruption.",
            "status": "pending",
            "testStrategy": "Perform codebase-wide search and refactor, then run integration tests to confirm all notifications are routed through the new infrastructure without regressions."
          }
        ]
      },
      {
        "id": 32,
        "title": "Implement Progress and Dialog Services with CLI Integration",
        "description": "Build ProgressService for standardized loading indicators and DialogService for unified input/confirmation patterns, with specialized CLI operation handling and timeout management.",
        "details": "Implement progress and dialog management services:\n\n1. **ProgressService.ts**: Standardize progress indication patterns\n```typescript\nexport class ProgressService {\n  async withProgress<T>(\n    config: ProgressConfig,\n    operation: (progress: ProgressReporter) => Promise<T>\n  ): Promise<T> {\n    return vscode.window.withProgress({\n      location: config.location || vscode.ProgressLocation.Notification,\n      title: config.title,\n      cancellable: config.cancellable || false\n    }, operation);\n  }\n\n  async withCLIProgress<T>(\n    command: string,\n    operation: () => Promise<T>,\n    config?: CLIProgressConfig\n  ): Promise<T> {\n    return this.withProgress({\n      title: `Running: ${command}`,\n      location: vscode.ProgressLocation.Window,\n      cancellable: true\n    }, async (progress) => {\n      const timeout = setTimeout(() => {\n        progress.report({ message: 'This is taking longer than expected...' });\n      }, config?.warningTimeout || 5000);\n      \n      try {\n        const result = await operation();\n        clearTimeout(timeout);\n        return result;\n      } catch (error) {\n        clearTimeout(timeout);\n        throw error;\n      }\n    });\n  }\n}\n```\n\n2. **DialogService.ts**: Unified dialog patterns\n```typescript\nexport class DialogService {\n  async quickPick<T>(\n    items: QuickPickItem<T>[],\n    config?: QuickPickConfig\n  ): Promise<T | undefined> {\n    const result = await vscode.window.showQuickPick(items, {\n      placeHolder: config?.placeholder,\n      canPickMany: config?.canPickMany || false,\n      ignoreFocusOut: config?.ignoreFocusOut || false\n    });\n    return result?.value;\n  }\n\n  async confirmWarning(\n    message: string,\n    options?: { modal?: boolean }\n  ): Promise<boolean> {\n    const result = await vscode.window.showWarningMessage(\n      message,\n      { modal: options?.modal || false },\n      'Yes',\n      'No'\n    );\n    return result === 'Yes';\n  }\n\n  async taskSelector(\n    tasks: Task[],\n    config?: TaskSelectorConfig\n  ): Promise<Task | undefined> {\n    const items = tasks.map(task => ({\n      label: `#${task.id}: ${task.title}`,\n      description: task.description,\n      value: task\n    }));\n    return this.quickPick(items, config);\n  }\n}\n```\n\n3. **CLI Integration**: Replace manual timeout handling in cliService.ts with standardized progress patterns\n4. **Dialog Builder**: Implement fluent API for complex multi-step dialogs\n5. **Keyboard Navigation**: Ensure proper focus management and accessibility\n\nLeverage VSCode's latest QuickPick API features including step navigation and validation.",
        "testStrategy": "Test progress cancellation behavior, CLI timeout handling, and dialog validation patterns. Mock long-running operations for progress testing. Verify keyboard navigation and accessibility compliance. Test dialog builder fluent API and multi-step workflows.",
        "priority": "high",
        "dependencies": [
          31
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement ProgressService for Standardized Loading Indicators",
            "description": "Develop ProgressService.ts to provide a unified API for progress indication, supporting both general and CLI-specific operations with timeout management.",
            "dependencies": [],
            "details": "Create methods such as withProgress and withCLIProgress to standardize progress reporting, leveraging VSCode's window.withProgress API and handling operation timeouts for CLI commands.",
            "status": "pending",
            "testStrategy": "Unit test withProgress and withCLIProgress for correct progress reporting, timeout handling, and error propagation using mocked VSCode APIs."
          },
          {
            "id": 2,
            "title": "Develop DialogService for Unified Input and Confirmation Patterns",
            "description": "Build DialogService.ts to encapsulate common dialog patterns, including quick pick lists, confirmation dialogs, and task selection.",
            "dependencies": [],
            "details": "Implement methods like quickPick, confirmWarning, and taskSelector using VSCode's showQuickPick and showWarningMessage APIs, ensuring consistent user experience.",
            "status": "pending",
            "testStrategy": "Unit test dialog methods for correct option rendering, selection handling, and modal behavior using mocked VSCode APIs."
          },
          {
            "id": 3,
            "title": "Integrate ProgressService with CLI Operations",
            "description": "Refactor cliService.ts to utilize ProgressService for all CLI-related progress and timeout handling, replacing manual implementations.",
            "dependencies": [
              1
            ],
            "details": "Update CLI operation flows to use withCLIProgress, ensuring standardized progress feedback and consistent timeout warnings for long-running commands.",
            "status": "pending",
            "testStrategy": "Integration test CLI operations to verify progress display, timeout messaging, and cancellation support."
          },
          {
            "id": 4,
            "title": "Implement Fluent Dialog Builder for Multi-Step Dialogs",
            "description": "Design and implement a fluent API within DialogService to support complex, multi-step dialog flows with step navigation and validation.",
            "dependencies": [
              2
            ],
            "details": "Leverage VSCode's latest QuickPick API features to enable step-by-step dialogs, input validation, and dynamic navigation between steps.",
            "status": "pending",
            "testStrategy": "Unit and integration test multi-step dialog flows for correct step transitions, validation enforcement, and user input handling."
          },
          {
            "id": 5,
            "title": "Ensure Keyboard Navigation and Accessibility Compliance",
            "description": "Enhance ProgressService and DialogService to support robust keyboard navigation and accessibility, ensuring focus management and screen reader compatibility.",
            "dependencies": [
              1,
              2,
              4
            ],
            "details": "Audit and update dialog and progress components to follow accessibility best practices, including focus trapping, ARIA attributes, and keyboard shortcuts.",
            "status": "pending",
            "testStrategy": "Manual and automated accessibility testing using screen readers and keyboard navigation tools to validate compliance."
          }
        ]
      },
      {
        "id": 33,
        "title": "Implement Error Handling, Workflow Services, and Complete Migration",
        "description": "Build comprehensive ErrorService for centralized error handling with recovery suggestions, implement WorkflowService for multi-step user flows, and complete migration of all 40+ try-catch blocks and interaction patterns across the codebase.",
        "details": "Complete the interaction system with error handling and workflows:\n\n1. **ErrorService.ts**: Centralized error management\n```typescript\nexport class ErrorService {\n  async handle(error: Error, context?: ErrorContext): Promise<void> {\n    const category = this.categorize(error);\n    const userMessage = this.formatUserMessage(error);\n    const suggestions = this.getSuggestions(error);\n    \n    if (category === ErrorCategory.CLI_ERROR) {\n      await this.handleCLIError(error as CLIError, context?.command || 'unknown');\n    } else {\n      await vscode.window.showErrorMessage(\n        userMessage,\n        ...suggestions.map(s => s.title)\n      );\n    }\n  }\n\n  categorize(error: Error): ErrorCategory {\n    if (error.message.includes('ENOENT')) return ErrorCategory.CLI_NOT_FOUND;\n    if (error.message.includes('timeout')) return ErrorCategory.TIMEOUT;\n    if (error.message.includes('permission')) return ErrorCategory.PERMISSION;\n    return ErrorCategory.UNKNOWN;\n  }\n\n  getSuggestions(error: Error): ErrorSuggestion[] {\n    const category = this.categorize(error);\n    switch (category) {\n      case ErrorCategory.CLI_NOT_FOUND:\n        return [{ title: 'Install CLI', action: 'install_cli' }];\n      case ErrorCategory.TIMEOUT:\n        return [{ title: 'Retry', action: 'retry' }, { title: 'Check Connection', action: 'check_connection' }];\n      default:\n        return [{ title: 'Report Issue', action: 'report_issue' }];\n    }\n  }\n}\n```\n\n2. **WorkflowService.ts**: Multi-step flow management\n```typescript\nexport class WorkflowService {\n  async addTaskWorkflow(): Promise<AddTaskResult | undefined> {\n    const builder = new WorkflowBuilder('add_task');\n    \n    return builder\n      .step('description', {\n        type: 'input',\n        title: 'Task Description',\n        placeholder: 'Describe what needs to be done...',\n        validate: (value) => value.length > 0 ? null : 'Description is required'\n      })\n      .step('priority', {\n        type: 'quickpick',\n        title: 'Select Priority',\n        items: [{ label: 'High', value: 'high' }, { label: 'Medium', value: 'medium' }, { label: 'Low', value: 'low' }]\n      })\n      .step('dependencies', {\n        type: 'multi_select',\n        title: 'Select Dependencies (Optional)',\n        items: await this.getAvailableTasks(),\n        optional: true\n      })\n      .onCancel(() => InteractionManager.getInstance().notify.info('Task creation cancelled'))\n      .execute();\n  }\n}\n```\n\n3. **Complete Migration**: \n   - Replace all 47+ showInformationMessage instances\n   - Replace all 26+ showErrorMessage instances  \n   - Replace all 25+ showWarningMessage instances\n   - Migrate 15+ showQuickPick instances\n   - Migrate 10+ showInputBox instances\n   - Replace 40+ try-catch blocks with centralized error handling\n\n4. **Theme Integration**: Implement consistent iconography and theme-aware styling\n5. **Testing Infrastructure**: Create comprehensive test suite with mocks and integration tests\n6. **Documentation**: Generate API documentation and migration guide\n\nUse TypeScript 4.9+ features for better type inference and error handling patterns.",
        "testStrategy": "Test error categorization accuracy, recovery suggestion relevance, and workflow step validation. Integration tests for complete user flows from start to finish. Test migration compatibility with existing functionality. Performance testing for large task lists and complex workflows. Accessibility testing for screen readers and keyboard navigation.",
        "priority": "medium",
        "dependencies": [
          32
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design and Implement Centralized ErrorService",
            "description": "Develop a robust ErrorService for centralized error handling, categorization, user messaging, and actionable recovery suggestions. Ensure all error objects follow a standardized interface and integrate consistent error reporting and logging across the application.",
            "dependencies": [],
            "details": "Create custom error classes, define error categories, and implement methods for formatting user messages and generating recovery suggestions. Ensure the service supports extensibility for new error types and integrates with the application's UI for user feedback.",
            "status": "pending",
            "testStrategy": "Unit test error categorization, message formatting, and suggestion generation. Mock error scenarios to verify correct handling and user feedback."
          },
          {
            "id": 2,
            "title": "Develop WorkflowService for Multi-Step User Flows",
            "description": "Implement a WorkflowService to manage complex, multi-step user interactions such as task creation, ensuring validation, cancellation, and dynamic step configuration.",
            "dependencies": [
              1
            ],
            "details": "Utilize a builder pattern to define workflows with input, quick pick, and multi-select steps. Integrate error handling at each step using ErrorService. Support extensibility for additional workflows.",
            "status": "pending",
            "testStrategy": "Integration test workflows with various user inputs, cancellations, and error scenarios. Validate correct step progression and error recovery."
          },
          {
            "id": 3,
            "title": "Migrate Legacy Interaction and Error Patterns",
            "description": "Replace all legacy try-catch blocks and direct UI message calls (showInformationMessage, showErrorMessage, showWarningMessage, showQuickPick, showInputBox) with the new ErrorService and WorkflowService patterns across the codebase.",
            "dependencies": [
              1,
              2
            ],
            "details": "Systematically refactor 40+ try-catch blocks and 100+ UI interaction instances to use centralized services. Ensure all error and interaction flows are consistent and leverage new recovery and workflow mechanisms.",
            "status": "pending",
            "testStrategy": "Regression test all migrated flows. Use static analysis to confirm removal of legacy patterns. Verify error and interaction consistency in the UI."
          },
          {
            "id": 4,
            "title": "Integrate Theme-Aware Styling and Iconography",
            "description": "Implement consistent iconography and theme-aware styling for all error messages, workflows, and user interactions to ensure a cohesive user experience.",
            "dependencies": [
              3
            ],
            "details": "Update UI components to use theme APIs and standardized icons. Ensure accessibility and visual consistency across light and dark themes.",
            "status": "pending",
            "testStrategy": "Visual regression testing across supported themes. Manual accessibility checks for color contrast and icon clarity."
          },
          {
            "id": 5,
            "title": "Establish Comprehensive Testing and Documentation",
            "description": "Develop a complete test suite with mocks and integration tests for ErrorService, WorkflowService, and all migrated flows. Generate API documentation and a migration guide for future maintainers.",
            "dependencies": [
              4
            ],
            "details": "Write unit and integration tests covering all error and workflow scenarios. Use TypeScript 4.9+ features for type-safe tests. Document APIs and provide a step-by-step migration guide.",
            "status": "pending",
            "testStrategy": "Automated test coverage reports. Peer review of documentation. Continuous integration to ensure test reliability."
          }
        ]
      },
      {
        "id": 34,
        "title": "Implement Enhanced Logger Core and VS Code Configuration",
        "description": "Build out the core logging library in src/utils/enhancedLogger.ts to support multiple log levels, structured data, context management, performance timing, and file+output channel outputs. Expose a getLogger factory that reads user settings and honors runtime changes.",
        "details": "* Use pino@8.16.0 as the underlying engine for structured, high-performance logging.  \n* Create src/utils/enhancedLogger.ts implementing the ILogger interface from the PRD.  \n* Read configuration via vscode.workspace.getConfiguration('taskMaster.logging') using TypeScript 5.4 APIs.  \n* Support log levels TRACE, DEBUG, INFO, WARN, ERROR, FATAL.  \n* Implement time()/timeEnd() via a Map of timestamps and include duration in context.  \n* Merge context via child() method to propagate correlationId, component, operation, etc.  \n* Wire up outputs:  \n  • vscode.window.createOutputChannel('Task Master Logs') for outputChannel  \n  • console via pino.prettyPrint for local dev  \n  • optional file logging via pino.destination with rotation (use rotating-file-stream@2.x)  \n* Listen to vscode.workspace.onDidChangeConfiguration to reload config at runtime.",
        "testStrategy": "* Write Jest 29 + ts-jest unit tests to mock pino logger and verify: proper level filtering, structured JSON output, context merging, timer start/end, hot-reload config.  \n* Validate that outputChannel append() is called for each log when enabled.  \n* Benchmark basic logging overhead <5% of operation time via a simple performance test.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design Multi-Level Structured Logging Architecture",
            "description": "Develop a comprehensive architecture for multi-level structured logging to enhance log clarity and facilitate efficient debugging.",
            "dependencies": [],
            "details": "This task involves defining a hierarchical logging structure that supports various log levels (e.g., DEBUG, INFO, WARN, ERROR) and ensures consistent formatting across all levels. The design should consider the inclusion of contextual metadata to provide detailed insights into application behavior.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement Performance Timing with Child Logger Functionality",
            "description": "Integrate performance timing mechanisms within the logging system using child loggers to monitor and log execution times of specific code segments.",
            "dependencies": [
              1
            ],
            "details": "This task requires the creation of child loggers that can be attached to specific functions or modules to measure and log their execution times. The implementation should ensure minimal performance overhead and provide precise timing data to aid in performance optimization efforts.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Develop Configurable Formatting and Output Options",
            "description": "Create a flexible configuration system for log formatting and output destinations to accommodate various operational requirements.",
            "dependencies": [
              1
            ],
            "details": "This task involves implementing a configuration mechanism that allows users to specify log formats (e.g., JSON, plain text) and select output destinations (e.g., console, files, external log management systems). The system should support dynamic configuration changes without requiring application restarts.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement Asynchronous Logging with Data Sanitization and Rate Limiting",
            "description": "Enhance the logging system with asynchronous capabilities, incorporating data sanitization and rate limiting to improve performance and security.",
            "dependencies": [
              1,
              3
            ],
            "details": "This task entails developing an asynchronous logging mechanism that queues log messages for processing, thereby reducing the impact on application performance. Additionally, it requires implementing data sanitization to prevent sensitive information from being logged and rate limiting to control the volume of log messages, preventing potential log flooding.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Integrate Logging System with Workspace Configuration in VS Code",
            "description": "Integrate the enhanced logging system with Visual Studio Code's workspace configuration to provide seamless logging management within the development environment.",
            "dependencies": [
              1,
              3
            ],
            "details": "This task involves creating an extension or utilizing existing APIs to allow developers to configure and manage the logging system directly from VS Code's workspace settings. The integration should support customization of log levels, formats, and output destinations, enhancing the developer experience.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 35,
        "title": "Integrate Logger into Core Services",
        "description": "Instrument critical services (CLIService, TaskManagerService, ConfigService, SecurityService) with the enhanced logger. Create a centralized error-logging utility to unify error capture and reporting.",
        "details": "* In each service constructor, import getLogger() and call .child({ component: '<ServiceName>' }).  \n* Wrap key methods with:  \n  • log.trace/debug at method entry  \n  • logger.time(operationId) before async operations  \n  • logger.timeEnd(operationId) and info on success  \n  • catch blocks that call logger.error(message, error, context) then rethrow.  \n* Build src/utils/errorHandler.ts exporting a handleError(error, context) that logs at ERROR or FATAL based on error type and provides a user-friendly message via vscode.window.showErrorMessage.  \n* Update ConfigService to log configuration changes and sanitized values, respecting workspace trust (vscode.workspace.isTrusted).",
        "testStrategy": "* Use sinon spies in existing Mocha or Jest tests to assert that logger.child(), .info(), .error(), .time(), .timeEnd() are called with correct parameters.  \n* Cover failure paths by simulating thrown errors and verifying handleError logs and UI notifications.  \n* Add integration tests ensuring correlationId flows through chained service calls.",
        "priority": "medium",
        "dependencies": [
          34
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Select a Structured Logging Library",
            "description": "Evaluate and choose a structured logging library that aligns with the project's technology stack and performance requirements.",
            "dependencies": [],
            "details": "Consider factors such as performance, integration capabilities, community support, and compatibility with existing systems. For example, in Python, libraries like 'structlog' offer structured logging with support for both synchronous and asynchronous methods. [Source: https://www.highlight.io/blog/5-best-python-logging-libraries]",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Replace Console Logging with Structured Logging",
            "description": "Systematically refactor existing console logging instances across critical services to utilize the selected structured logging library.",
            "dependencies": [
              1
            ],
            "details": "This involves updating over 120 logging instances to ensure consistency and leverage the benefits of structured logging, such as improved searchability and analysis. [Source: https://www.crowdstrike.com/en-us/cybersecurity-101/next-gen-siem/logging-best-practices/]",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement Enhanced Service-Specific Logging Features",
            "description": "Develop and integrate additional logging features tailored to the specific needs of each critical service.",
            "dependencies": [
              2
            ],
            "details": "This may include adding contextual information, implementing correlation IDs for tracing requests across services, and ensuring logs capture relevant metadata. [Source: https://signoz.io/blog/structured-logs/]",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Establish Centralized Error Handling with Diagnostic Context",
            "description": "Set up a centralized error handling mechanism that incorporates diagnostic context to facilitate efficient troubleshooting.",
            "dependencies": [
              3
            ],
            "details": "This involves aggregating logs from various services into a centralized system, enabling comprehensive analysis and quicker identification of issues. [Source: https://www.crowdstrike.com/en-us/cybersecurity-101/next-gen-siem/logging-best-practices/]",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Conduct Comprehensive Validation and Documentation",
            "description": "Perform thorough testing of the new logging implementation and create detailed documentation for future reference.",
            "dependencies": [
              4
            ],
            "details": "Validation should ensure that all logging instances function correctly and meet the project's requirements. Documentation should cover the logging setup, usage guidelines, and maintenance procedures. [Source: https://www.crowdstrike.com/en-us/cybersecurity-101/next-gen-siem/logging-best-practices/]",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 36,
        "title": "Migrate Commands and Providers to Enhanced Logging",
        "description": "Replace all console.log/error calls in commands and the TaskTreeProvider with the new logger. Add contextual and performance logging in command execution and tree rendering.",
        "details": "* Use ESLint rule no-console to locate and auto-fix console.* to appropriate logger methods.  \n* In each command handler:  \n  • generate correlationId and child logger with { operation: commandId, correlationId }  \n  • log .info('Starting command', { args })  \n  • call .time()/.timeEnd() around RPC or CLI execution  \n  • catch and call logger.error + throw.  \n* In TaskTreeProvider:  \n  • on tree refresh, call logger.time('tree-refresh') and log duration on end.  \n  • include node context metadata in logs.  \n* Ensure no sensitive data in logs by sanitizing file paths with path.relative or masking.  \n* Enforce structured JSON format for all new logs.",
        "testStrategy": "* End-to-end tests via vscode-test: invoke commands and capture outputChannel logs, verify presence of structured JSON entries, correlationId consistency, and duration metrics.  \n* Static analysis CI job fails on any console.* usage.  \n* Manual smoke test in a trusted/untrusted workspace to confirm security-aware logging behavior.",
        "priority": "medium",
        "dependencies": [
          35
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Comprehensive Command and Provider Logging Updates",
            "description": "Enhance the logging system to capture detailed command and provider activities for improved traceability and debugging.",
            "dependencies": [],
            "details": "Update the existing logging framework to include detailed logs for all command executions and provider interactions. Ensure that logs are structured and categorized appropriately to facilitate easy analysis and troubleshooting.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Enhance Configuration Management",
            "description": "Strengthen configuration management practices to ensure system consistency and reliability.",
            "dependencies": [
              1
            ],
            "details": "Develop and enforce configuration policies that define standard settings for all system components. Implement version control for configuration files and establish procedures for change management to prevent unauthorized modifications.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-06-17T14:01:27.651Z",
      "updated": "2025-06-22T06:13:31.112Z",
      "description": "Tasks for master context"
    }
  }
}